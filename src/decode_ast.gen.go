// Copyright 2014-2015 The project AUTHORS. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// DO NOT EDIT: This source file has been generated by gen/gen_ast_decoder.go

package src

import (
	"errors"
	"fmt"
	"io"

	"github.com/DevMine/srcanlzr/src/ast"
	"github.com/DevMine/srcanlzr/src/token"
)

// decodeExprs decodes a list of expression objects.
func (dec *decoder) decodeExprs() []ast.Expr {
	if !dec.assertNewArray() {
		return nil
	}

	exprs := []ast.Expr{}

	if dec.isEmptyArray() {
		return exprs
	}
	if dec.err != nil {
		return nil
	}

	for {
		expr := dec.decodeExpr()
		if dec.err != nil {
			return nil
		}

		exprs = append(exprs, expr)

		if dec.isEndArray() {
			break
		}
		if dec.err != nil {
			return nil
		}
	}

	return exprs
}

// decodeStmts decodes a list of expression objects.
func (dec *decoder) decodeStmts() []ast.Stmt {
	if !dec.assertNewArray() {
		return nil
	}

	stmts := []ast.Stmt{}

	if dec.isEmptyArray() {
		return stmts
	}
	if dec.err != nil {
		return nil
	}

	for {
		stmt := dec.decodeStmt()
		if dec.err != nil {
			return nil
		}

		stmts = append(stmts, stmt)

		if dec.isEndArray() {
			break
		}
		if dec.err != nil {
			return nil
		}
	}

	return stmts
}

func (dec *decoder) decodeExpr() ast.Expr {
	if !dec.assertNewObject() {
		return nil
	}

	// Expression cannot be an empty object because ast.Expr is an interface
	// and we need the value corresponding to the "expression_name" to allocate
	// the appropriate type.
	if dec.isEmptyObject() {
		dec.err = errors.New("expression object cannot be empty")
		return nil
	}
	if dec.err != nil {
		return nil
	}
	exprName := dec.extractFirstKey("expression_name")
	if dec.err != nil {
		return nil
	}
	if dec.isEndObject() {
		dec.err = errors.New("expression object cannot be empty")
		return nil
	}

	// Since the beginning of the object has already been consumed, we need
	// special methods for only decoding the attributes.

	var expr ast.Expr
	switch exprName {

	case token.ArrayExprName:
		expr = dec.decodeArrayExprAttrs()

	case token.ArrayLitName:
		expr = dec.decodeArrayLitAttrs()

	case token.AttrRefName:
		expr = dec.decodeAttrRefAttrs()

	case token.BasicLitName:
		expr = dec.decodeBasicLitAttrs()

	case token.BinaryExprName:
		expr = dec.decodeBinaryExprAttrs()

	case token.CallExprName:
		expr = dec.decodeCallExprAttrs()

	case token.ClassLitName:
		expr = dec.decodeClassLitAttrs()

	case token.ConstructorCallExprName:
		expr = dec.decodeConstructorCallExprAttrs()

	case token.FuncLitName:
		expr = dec.decodeFuncLitAttrs()

	case token.IdentName:
		expr = dec.decodeIdentAttrs()

	case token.IncDecExprName:
		expr = dec.decodeIncDecExprAttrs()

	case token.IndexExprName:
		expr = dec.decodeIndexExprAttrs()

	case token.StructTypeName:
		expr = dec.decodeStructTypeAttrs()

	case token.TernaryExprName:
		expr = dec.decodeTernaryExprAttrs()

	case token.UnaryExprName:
		expr = dec.decodeUnaryExprAttrs()

	case token.ValueSpecName:
		expr = dec.decodeValueSpecAttrs()

	default:
		dec.err = fmt.Errorf("unknown expression '%s'", exprName)
		return nil
	}
	if dec.err != nil {
		return nil
	}
	return expr
}

func (dec *decoder) decodeArrayExpr() *ast.ArrayExpr {
	if !dec.assertNewObject() {
		return nil
	}
	if dec.isEmptyObject() {
		dec.err = errors.New("ArrayExpr object cannot be empty")
		return nil
	}
	if dec.err != nil {
		return nil
	}
	return dec.decodeArrayExprAttrs()
}

func (dec *decoder) decodeArrayExprAttrs() *ast.ArrayExpr {
	expr := ast.ArrayExpr{}
	expr.ExprName = token.ArrayExprName
	for {
		key, err := dec.scan.nextKey()
		if err != nil {
			if err == io.EOF {
				break
			}
			dec.err = err
			return nil
		}
		if key == "" {
			dec.err = errors.New("empty key")
			return nil
		}

		val, tok, err := dec.scan.nextValue()

		if err != nil {
			dec.err = err
			return nil
		}

		if tok != scanNullVal {
			switch key {

			case "expression_name":

				if tok != scanStringLit {
					dec.err = fmt.Errorf("expected 'String literal', found '%v'", tok)
					return nil
				}
				expr.ExprName, dec.err = dec.unmarshalString(val)

			case "type":

				dec.scan.back()

				expr.Type = dec.decodeArrayType()

			default:
				dec.err = fmt.Errorf("unexpected key '%s' for ArrayExpr object", key)
			}
		}

		if dec.err != nil {
			return nil
		}

		if dec.isEndObject() {
			break
		}
		if err != nil {
			return nil
		}
	}
	return &expr
}

func (dec *decoder) decodeArrayLit() *ast.ArrayLit {
	if !dec.assertNewObject() {
		return nil
	}
	if dec.isEmptyObject() {
		dec.err = errors.New("ArrayLit object cannot be empty")
		return nil
	}
	if dec.err != nil {
		return nil
	}
	return dec.decodeArrayLitAttrs()
}

func (dec *decoder) decodeArrayLitAttrs() *ast.ArrayLit {
	expr := ast.ArrayLit{}
	expr.ExprName = token.ArrayLitName
	for {
		key, err := dec.scan.nextKey()
		if err != nil {
			if err == io.EOF {
				break
			}
			dec.err = err
			return nil
		}
		if key == "" {
			dec.err = errors.New("empty key")
			return nil
		}

		val, tok, err := dec.scan.nextValue()

		if err != nil {
			dec.err = err
			return nil
		}

		if tok != scanNullVal {
			switch key {

			case "expression_name":

				if tok != scanStringLit {
					dec.err = fmt.Errorf("expected 'String literal', found '%v'", tok)
					return nil
				}
				expr.ExprName, dec.err = dec.unmarshalString(val)

			case "type":

				dec.scan.back()

				expr.Type = dec.decodeArrayType()

			case "elements":

				dec.scan.back()

				expr.Elts = dec.decodeExprs()

			default:
				dec.err = fmt.Errorf("unexpected key '%s' for ArrayLit object", key)
			}
		}

		if dec.err != nil {
			return nil
		}

		if dec.isEndObject() {
			break
		}
		if err != nil {
			return nil
		}
	}
	return &expr
}

func (dec *decoder) decodeAttrRef() *ast.AttrRef {
	if !dec.assertNewObject() {
		return nil
	}
	if dec.isEmptyObject() {
		dec.err = errors.New("AttrRef object cannot be empty")
		return nil
	}
	if dec.err != nil {
		return nil
	}
	return dec.decodeAttrRefAttrs()
}

func (dec *decoder) decodeAttrRefAttrs() *ast.AttrRef {
	expr := ast.AttrRef{}
	expr.ExprName = token.AttrRefName
	for {
		key, err := dec.scan.nextKey()
		if err != nil {
			if err == io.EOF {
				break
			}
			dec.err = err
			return nil
		}
		if key == "" {
			dec.err = errors.New("empty key")
			return nil
		}

		val, tok, err := dec.scan.nextValue()

		if err != nil {
			dec.err = err
			return nil
		}

		if tok != scanNullVal {
			switch key {

			case "expression_name":

				if tok != scanStringLit {
					dec.err = fmt.Errorf("expected 'String literal', found '%v'", tok)
					return nil
				}
				expr.ExprName, dec.err = dec.unmarshalString(val)

			case "name":

				dec.scan.back()

				expr.Name = dec.decodeIdent()

			default:
				dec.err = fmt.Errorf("unexpected key '%s' for AttrRef object", key)
			}
		}

		if dec.err != nil {
			return nil
		}

		if dec.isEndObject() {
			break
		}
		if err != nil {
			return nil
		}
	}
	return &expr
}

func (dec *decoder) decodeBasicLit() *ast.BasicLit {
	if !dec.assertNewObject() {
		return nil
	}
	if dec.isEmptyObject() {
		dec.err = errors.New("BasicLit object cannot be empty")
		return nil
	}
	if dec.err != nil {
		return nil
	}
	return dec.decodeBasicLitAttrs()
}

func (dec *decoder) decodeBasicLitAttrs() *ast.BasicLit {
	expr := ast.BasicLit{}
	expr.ExprName = token.BasicLitName
	for {
		key, err := dec.scan.nextKey()
		if err != nil {
			if err == io.EOF {
				break
			}
			dec.err = err
			return nil
		}
		if key == "" {
			dec.err = errors.New("empty key")
			return nil
		}

		val, tok, err := dec.scan.nextValue()

		if err != nil {
			dec.err = err
			return nil
		}

		if tok != scanNullVal {
			switch key {

			case "expression_name":

				if tok != scanStringLit {
					dec.err = fmt.Errorf("expected 'String literal', found '%v'", tok)
					return nil
				}
				expr.ExprName, dec.err = dec.unmarshalString(val)

			case "kind":

				if tok != scanStringLit {
					dec.err = fmt.Errorf("expected 'String literal', found '%v'", tok)
					return nil
				}
				expr.Kind, dec.err = dec.unmarshalString(val)

			case "value":

				if tok != scanStringLit {
					dec.err = fmt.Errorf("expected 'String literal', found '%v'", tok)
					return nil
				}
				expr.Value, dec.err = dec.unmarshalString(val)

			default:
				dec.err = fmt.Errorf("unexpected key '%s' for BasicLit object", key)
			}
		}

		if dec.err != nil {
			return nil
		}

		if dec.isEndObject() {
			break
		}
		if err != nil {
			return nil
		}
	}
	return &expr
}

func (dec *decoder) decodeBinaryExpr() *ast.BinaryExpr {
	if !dec.assertNewObject() {
		return nil
	}
	if dec.isEmptyObject() {
		dec.err = errors.New("BinaryExpr object cannot be empty")
		return nil
	}
	if dec.err != nil {
		return nil
	}
	return dec.decodeBinaryExprAttrs()
}

func (dec *decoder) decodeBinaryExprAttrs() *ast.BinaryExpr {
	expr := ast.BinaryExpr{}
	expr.ExprName = token.BinaryExprName
	for {
		key, err := dec.scan.nextKey()
		if err != nil {
			if err == io.EOF {
				break
			}
			dec.err = err
			return nil
		}
		if key == "" {
			dec.err = errors.New("empty key")
			return nil
		}

		val, tok, err := dec.scan.nextValue()

		if err != nil {
			dec.err = err
			return nil
		}

		if tok != scanNullVal {
			switch key {

			case "expression_name":

				if tok != scanStringLit {
					dec.err = fmt.Errorf("expected 'String literal', found '%v'", tok)
					return nil
				}
				expr.ExprName, dec.err = dec.unmarshalString(val)

			case "left_expression":

				dec.scan.back()

				expr.LeftExpr = dec.decodeExpr()

			case "operator":

				if tok != scanStringLit {
					dec.err = fmt.Errorf("expected 'String literal', found '%v'", tok)
					return nil
				}
				expr.Op, dec.err = dec.unmarshalString(val)

			case "right_expression":

				dec.scan.back()

				expr.RightExpr = dec.decodeExpr()

			default:
				dec.err = fmt.Errorf("unexpected key '%s' for BinaryExpr object", key)
			}
		}

		if dec.err != nil {
			return nil
		}

		if dec.isEndObject() {
			break
		}
		if err != nil {
			return nil
		}
	}
	return &expr
}

func (dec *decoder) decodeCallExpr() *ast.CallExpr {
	if !dec.assertNewObject() {
		return nil
	}
	if dec.isEmptyObject() {
		dec.err = errors.New("CallExpr object cannot be empty")
		return nil
	}
	if dec.err != nil {
		return nil
	}
	return dec.decodeCallExprAttrs()
}

func (dec *decoder) decodeCallExprAttrs() *ast.CallExpr {
	expr := ast.CallExpr{}
	expr.ExprName = token.CallExprName
	for {
		key, err := dec.scan.nextKey()
		if err != nil {
			if err == io.EOF {
				break
			}
			dec.err = err
			return nil
		}
		if key == "" {
			dec.err = errors.New("empty key")
			return nil
		}

		val, tok, err := dec.scan.nextValue()

		if err != nil {
			dec.err = err
			return nil
		}

		if tok != scanNullVal {
			switch key {

			case "expression_name":

				if tok != scanStringLit {
					dec.err = fmt.Errorf("expected 'String literal', found '%v'", tok)
					return nil
				}
				expr.ExprName, dec.err = dec.unmarshalString(val)

			case "function":

				dec.scan.back()

				expr.Fun = dec.decodeFuncRef()

			case "arguments":

				dec.scan.back()

				expr.Args = dec.decodeExprs()

			case "line":

				if tok != scanInt64Lit {
					dec.err = fmt.Errorf("expected 'Int64 literal', found '%v'", tok)
					return nil
				}
				expr.Line, dec.err = dec.unmarshalInt64(val)

			default:
				dec.err = fmt.Errorf("unexpected key '%s' for CallExpr object", key)
			}
		}

		if dec.err != nil {
			return nil
		}

		if dec.isEndObject() {
			break
		}
		if err != nil {
			return nil
		}
	}
	return &expr
}

func (dec *decoder) decodeClassLit() *ast.ClassLit {
	if !dec.assertNewObject() {
		return nil
	}
	if dec.isEmptyObject() {
		dec.err = errors.New("ClassLit object cannot be empty")
		return nil
	}
	if dec.err != nil {
		return nil
	}
	return dec.decodeClassLitAttrs()
}

func (dec *decoder) decodeClassLitAttrs() *ast.ClassLit {
	expr := ast.ClassLit{}
	expr.ExprName = token.ClassLitName
	for {
		key, err := dec.scan.nextKey()
		if err != nil {
			if err == io.EOF {
				break
			}
			dec.err = err
			return nil
		}
		if key == "" {
			dec.err = errors.New("empty key")
			return nil
		}

		val, tok, err := dec.scan.nextValue()

		if err != nil {
			dec.err = err
			return nil
		}

		if tok != scanNullVal {
			switch key {

			case "expression_name":

				if tok != scanStringLit {
					dec.err = fmt.Errorf("expected 'String literal', found '%v'", tok)
					return nil
				}
				expr.ExprName, dec.err = dec.unmarshalString(val)

			case "extended_classes":

				dec.scan.back()

				expr.ExtendedClasses = dec.decodeClassRefs()

			case "implemented_interfaces":

				dec.scan.back()

				expr.ImplementedInterfaces = dec.decodeInterfaceRefs()

			case "attributes":

				dec.scan.back()

				expr.Attrs = dec.decodeAttrs()

			case "constructors":

				dec.scan.back()

				expr.Constructors = dec.decodeConstructorDecls()

			case "destructors":

				dec.scan.back()

				expr.Destructors = dec.decodeDestructorDecls()

			case "methods":

				dec.scan.back()

				expr.Methods = dec.decodeMethodDecls()

			default:
				dec.err = fmt.Errorf("unexpected key '%s' for ClassLit object", key)
			}
		}

		if dec.err != nil {
			return nil
		}

		if dec.isEndObject() {
			break
		}
		if err != nil {
			return nil
		}
	}
	return &expr
}

func (dec *decoder) decodeConstructorCallExpr() *ast.ConstructorCallExpr {
	if !dec.assertNewObject() {
		return nil
	}
	if dec.isEmptyObject() {
		dec.err = errors.New("ConstructorCallExpr object cannot be empty")
		return nil
	}
	if dec.err != nil {
		return nil
	}
	return dec.decodeConstructorCallExprAttrs()
}

func (dec *decoder) decodeConstructorCallExprAttrs() *ast.ConstructorCallExpr {
	expr := ast.ConstructorCallExpr{}
	expr.ExprName = token.ConstructorCallExprName
	for {
		key, err := dec.scan.nextKey()
		if err != nil {
			if err == io.EOF {
				break
			}
			dec.err = err
			return nil
		}
		if key == "" {
			dec.err = errors.New("empty key")
			return nil
		}

		val, tok, err := dec.scan.nextValue()

		if err != nil {
			dec.err = err
			return nil
		}

		if tok != scanNullVal {
			switch key {

			case "expression_name":

				if tok != scanStringLit {
					dec.err = fmt.Errorf("expected 'String literal', found '%v'", tok)
					return nil
				}
				expr.ExprName, dec.err = dec.unmarshalString(val)

			case "function":

				dec.scan.back()

				expr.Fun = dec.decodeFuncRef()

			case "arguments":

				dec.scan.back()

				expr.Args = dec.decodeExprs()

			case "line":

				if tok != scanInt64Lit {
					dec.err = fmt.Errorf("expected 'Int64 literal', found '%v'", tok)
					return nil
				}
				expr.Line, dec.err = dec.unmarshalInt64(val)

			default:
				dec.err = fmt.Errorf("unexpected key '%s' for ConstructorCallExpr object", key)
			}
		}

		if dec.err != nil {
			return nil
		}

		if dec.isEndObject() {
			break
		}
		if err != nil {
			return nil
		}
	}
	return &expr
}

func (dec *decoder) decodeFuncLit() *ast.FuncLit {
	if !dec.assertNewObject() {
		return nil
	}
	if dec.isEmptyObject() {
		dec.err = errors.New("FuncLit object cannot be empty")
		return nil
	}
	if dec.err != nil {
		return nil
	}
	return dec.decodeFuncLitAttrs()
}

func (dec *decoder) decodeFuncLitAttrs() *ast.FuncLit {
	expr := ast.FuncLit{}
	expr.ExprName = token.FuncLitName
	for {
		key, err := dec.scan.nextKey()
		if err != nil {
			if err == io.EOF {
				break
			}
			dec.err = err
			return nil
		}
		if key == "" {
			dec.err = errors.New("empty key")
			return nil
		}

		val, tok, err := dec.scan.nextValue()

		if err != nil {
			dec.err = err
			return nil
		}

		if tok != scanNullVal {
			switch key {

			case "expression_name":

				if tok != scanStringLit {
					dec.err = fmt.Errorf("expected 'String literal', found '%v'", tok)
					return nil
				}
				expr.ExprName, dec.err = dec.unmarshalString(val)

			case "type":

				dec.scan.back()

				expr.Type = dec.decodeFuncType()

			case "body":

				dec.scan.back()

				expr.Body = dec.decodeStmts()

			case "loc":

				if tok != scanInt64Lit {
					dec.err = fmt.Errorf("expected 'Int64 literal', found '%v'", tok)
					return nil
				}
				expr.LoC, dec.err = dec.unmarshalInt64(val)

			default:
				dec.err = fmt.Errorf("unexpected key '%s' for FuncLit object", key)
			}
		}

		if dec.err != nil {
			return nil
		}

		if dec.isEndObject() {
			break
		}
		if err != nil {
			return nil
		}
	}
	return &expr
}

func (dec *decoder) decodeIdent() *ast.Ident {
	if !dec.assertNewObject() {
		return nil
	}
	if dec.isEmptyObject() {
		dec.err = errors.New("Ident object cannot be empty")
		return nil
	}
	if dec.err != nil {
		return nil
	}
	return dec.decodeIdentAttrs()
}

func (dec *decoder) decodeIdentAttrs() *ast.Ident {
	expr := ast.Ident{}
	expr.ExprName = token.IdentName
	for {
		key, err := dec.scan.nextKey()
		if err != nil {
			if err == io.EOF {
				break
			}
			dec.err = err
			return nil
		}
		if key == "" {
			dec.err = errors.New("empty key")
			return nil
		}

		val, tok, err := dec.scan.nextValue()

		if err != nil {
			dec.err = err
			return nil
		}

		if tok != scanNullVal {
			switch key {

			case "expression_name":

				if tok != scanStringLit {
					dec.err = fmt.Errorf("expected 'String literal', found '%v'", tok)
					return nil
				}
				expr.ExprName, dec.err = dec.unmarshalString(val)

			case "name":

				if tok != scanStringLit {
					dec.err = fmt.Errorf("expected 'String literal', found '%v'", tok)
					return nil
				}
				expr.Name, dec.err = dec.unmarshalString(val)

			default:
				dec.err = fmt.Errorf("unexpected key '%s' for Ident object", key)
			}
		}

		if dec.err != nil {
			return nil
		}

		if dec.isEndObject() {
			break
		}
		if err != nil {
			return nil
		}
	}
	return &expr
}

func (dec *decoder) decodeIncDecExpr() *ast.IncDecExpr {
	if !dec.assertNewObject() {
		return nil
	}
	if dec.isEmptyObject() {
		dec.err = errors.New("IncDecExpr object cannot be empty")
		return nil
	}
	if dec.err != nil {
		return nil
	}
	return dec.decodeIncDecExprAttrs()
}

func (dec *decoder) decodeIncDecExprAttrs() *ast.IncDecExpr {
	expr := ast.IncDecExpr{}
	expr.ExprName = token.IncDecExprName
	for {
		key, err := dec.scan.nextKey()
		if err != nil {
			if err == io.EOF {
				break
			}
			dec.err = err
			return nil
		}
		if key == "" {
			dec.err = errors.New("empty key")
			return nil
		}

		val, tok, err := dec.scan.nextValue()

		if err != nil {
			dec.err = err
			return nil
		}

		if tok != scanNullVal {
			switch key {

			case "expression_name":

				if tok != scanStringLit {
					dec.err = fmt.Errorf("expected 'String literal', found '%v'", tok)
					return nil
				}
				expr.ExprName, dec.err = dec.unmarshalString(val)

			case "operand":

				dec.scan.back()

				expr.X = dec.decodeExpr()

			case "operator":

				if tok != scanStringLit {
					dec.err = fmt.Errorf("expected 'String literal', found '%v'", tok)
					return nil
				}
				expr.Op, dec.err = dec.unmarshalString(val)

			case "is_pre":

				if tok != scanBoolLit {
					dec.err = fmt.Errorf("expected 'Bool literal', found '%v'", tok)
					return nil
				}
				expr.IsPre, dec.err = dec.unmarshalBool(val)

			default:
				dec.err = fmt.Errorf("unexpected key '%s' for IncDecExpr object", key)
			}
		}

		if dec.err != nil {
			return nil
		}

		if dec.isEndObject() {
			break
		}
		if err != nil {
			return nil
		}
	}
	return &expr
}

func (dec *decoder) decodeIndexExpr() *ast.IndexExpr {
	if !dec.assertNewObject() {
		return nil
	}
	if dec.isEmptyObject() {
		dec.err = errors.New("IndexExpr object cannot be empty")
		return nil
	}
	if dec.err != nil {
		return nil
	}
	return dec.decodeIndexExprAttrs()
}

func (dec *decoder) decodeIndexExprAttrs() *ast.IndexExpr {
	expr := ast.IndexExpr{}
	expr.ExprName = token.IndexExprName
	for {
		key, err := dec.scan.nextKey()
		if err != nil {
			if err == io.EOF {
				break
			}
			dec.err = err
			return nil
		}
		if key == "" {
			dec.err = errors.New("empty key")
			return nil
		}

		val, tok, err := dec.scan.nextValue()

		if err != nil {
			dec.err = err
			return nil
		}

		if tok != scanNullVal {
			switch key {

			case "expression_name":

				if tok != scanStringLit {
					dec.err = fmt.Errorf("expected 'String literal', found '%v'", tok)
					return nil
				}
				expr.ExprName, dec.err = dec.unmarshalString(val)

			case "expression":

				dec.scan.back()

				expr.X = dec.decodeExpr()

			case "index":

				dec.scan.back()

				expr.Index = dec.decodeExpr()

			default:
				dec.err = fmt.Errorf("unexpected key '%s' for IndexExpr object", key)
			}
		}

		if dec.err != nil {
			return nil
		}

		if dec.isEndObject() {
			break
		}
		if err != nil {
			return nil
		}
	}
	return &expr
}

func (dec *decoder) decodeStructType() *ast.StructType {
	if !dec.assertNewObject() {
		return nil
	}
	if dec.isEmptyObject() {
		dec.err = errors.New("StructType object cannot be empty")
		return nil
	}
	if dec.err != nil {
		return nil
	}
	return dec.decodeStructTypeAttrs()
}

func (dec *decoder) decodeStructTypeAttrs() *ast.StructType {
	expr := ast.StructType{}
	expr.ExprName = token.StructTypeName
	for {
		key, err := dec.scan.nextKey()
		if err != nil {
			if err == io.EOF {
				break
			}
			dec.err = err
			return nil
		}
		if key == "" {
			dec.err = errors.New("empty key")
			return nil
		}

		val, tok, err := dec.scan.nextValue()

		if err != nil {
			dec.err = err
			return nil
		}

		if tok != scanNullVal {
			switch key {

			case "expression_name":

				if tok != scanStringLit {
					dec.err = fmt.Errorf("expected 'String literal', found '%v'", tok)
					return nil
				}
				expr.ExprName, dec.err = dec.unmarshalString(val)

			case "doc":

				dec.scan.back()

				expr.Doc = dec.decodeStrings()

			case "name":

				dec.scan.back()

				expr.Name = dec.decodeIdent()

			case "fields":

				dec.scan.back()

				expr.Fields = dec.decodeFields()

			default:
				dec.err = fmt.Errorf("unexpected key '%s' for StructType object", key)
			}
		}

		if dec.err != nil {
			return nil
		}

		if dec.isEndObject() {
			break
		}
		if err != nil {
			return nil
		}
	}
	return &expr
}

func (dec *decoder) decodeTernaryExpr() *ast.TernaryExpr {
	if !dec.assertNewObject() {
		return nil
	}
	if dec.isEmptyObject() {
		dec.err = errors.New("TernaryExpr object cannot be empty")
		return nil
	}
	if dec.err != nil {
		return nil
	}
	return dec.decodeTernaryExprAttrs()
}

func (dec *decoder) decodeTernaryExprAttrs() *ast.TernaryExpr {
	expr := ast.TernaryExpr{}
	expr.ExprName = token.TernaryExprName
	for {
		key, err := dec.scan.nextKey()
		if err != nil {
			if err == io.EOF {
				break
			}
			dec.err = err
			return nil
		}
		if key == "" {
			dec.err = errors.New("empty key")
			return nil
		}

		val, tok, err := dec.scan.nextValue()

		if err != nil {
			dec.err = err
			return nil
		}

		if tok != scanNullVal {
			switch key {

			case "expression_name":

				if tok != scanStringLit {
					dec.err = fmt.Errorf("expected 'String literal', found '%v'", tok)
					return nil
				}
				expr.ExprName, dec.err = dec.unmarshalString(val)

			case "condition":

				dec.scan.back()

				expr.Cond = dec.decodeExpr()

			case "then":

				dec.scan.back()

				expr.Then = dec.decodeExpr()

			case "else":

				dec.scan.back()

				expr.Else = dec.decodeExpr()

			default:
				dec.err = fmt.Errorf("unexpected key '%s' for TernaryExpr object", key)
			}
		}

		if dec.err != nil {
			return nil
		}

		if dec.isEndObject() {
			break
		}
		if err != nil {
			return nil
		}
	}
	return &expr
}

func (dec *decoder) decodeUnaryExpr() *ast.UnaryExpr {
	if !dec.assertNewObject() {
		return nil
	}
	if dec.isEmptyObject() {
		dec.err = errors.New("UnaryExpr object cannot be empty")
		return nil
	}
	if dec.err != nil {
		return nil
	}
	return dec.decodeUnaryExprAttrs()
}

func (dec *decoder) decodeUnaryExprAttrs() *ast.UnaryExpr {
	expr := ast.UnaryExpr{}
	expr.ExprName = token.UnaryExprName
	for {
		key, err := dec.scan.nextKey()
		if err != nil {
			if err == io.EOF {
				break
			}
			dec.err = err
			return nil
		}
		if key == "" {
			dec.err = errors.New("empty key")
			return nil
		}

		val, tok, err := dec.scan.nextValue()

		if err != nil {
			dec.err = err
			return nil
		}

		if tok != scanNullVal {
			switch key {

			case "expression_name":

				if tok != scanStringLit {
					dec.err = fmt.Errorf("expected 'String literal', found '%v'", tok)
					return nil
				}
				expr.ExprName, dec.err = dec.unmarshalString(val)

			case "operator":

				if tok != scanStringLit {
					dec.err = fmt.Errorf("expected 'String literal', found '%v'", tok)
					return nil
				}
				expr.Op, dec.err = dec.unmarshalString(val)

			case "operand":

				dec.scan.back()

				expr.X = dec.decodeExpr()

			default:
				dec.err = fmt.Errorf("unexpected key '%s' for UnaryExpr object", key)
			}
		}

		if dec.err != nil {
			return nil
		}

		if dec.isEndObject() {
			break
		}
		if err != nil {
			return nil
		}
	}
	return &expr
}

func (dec *decoder) decodeValueSpec() *ast.ValueSpec {
	if !dec.assertNewObject() {
		return nil
	}
	if dec.isEmptyObject() {
		dec.err = errors.New("ValueSpec object cannot be empty")
		return nil
	}
	if dec.err != nil {
		return nil
	}
	return dec.decodeValueSpecAttrs()
}

func (dec *decoder) decodeValueSpecAttrs() *ast.ValueSpec {
	expr := ast.ValueSpec{}
	expr.ExprName = token.ValueSpecName
	for {
		key, err := dec.scan.nextKey()
		if err != nil {
			if err == io.EOF {
				break
			}
			dec.err = err
			return nil
		}
		if key == "" {
			dec.err = errors.New("empty key")
			return nil
		}

		val, tok, err := dec.scan.nextValue()

		if err != nil {
			dec.err = err
			return nil
		}

		if tok != scanNullVal {
			switch key {

			case "expression_name":

				if tok != scanStringLit {
					dec.err = fmt.Errorf("expected 'String literal', found '%v'", tok)
					return nil
				}
				expr.ExprName, dec.err = dec.unmarshalString(val)

			case "name":

				dec.scan.back()

				expr.Name = dec.decodeIdent()

			case "type":

				dec.scan.back()

				expr.Type = dec.decodeIdent()

			default:
				dec.err = fmt.Errorf("unexpected key '%s' for ValueSpec object", key)
			}
		}

		if dec.err != nil {
			return nil
		}

		if dec.isEndObject() {
			break
		}
		if err != nil {
			return nil
		}
	}
	return &expr
}

func (dec *decoder) decodeArrayExprs() []*ast.ArrayExpr {
	if !dec.assertNewArray() {
		return nil
	}

	a := []*ast.ArrayExpr{}

	if dec.isEmptyArray() {
		return a
	}
	if dec.err != nil {
		return nil
	}

	for {
		elt := dec.decodeArrayExpr()
		if dec.err != nil {
			return nil
		}

		a = append(a, elt)

		if dec.isEndArray() {
			break
		}
		if dec.err != nil {
			return nil
		}
	}

	return a
}

func (dec *decoder) decodeArrayLits() []*ast.ArrayLit {
	if !dec.assertNewArray() {
		return nil
	}

	a := []*ast.ArrayLit{}

	if dec.isEmptyArray() {
		return a
	}
	if dec.err != nil {
		return nil
	}

	for {
		elt := dec.decodeArrayLit()
		if dec.err != nil {
			return nil
		}

		a = append(a, elt)

		if dec.isEndArray() {
			break
		}
		if dec.err != nil {
			return nil
		}
	}

	return a
}

func (dec *decoder) decodeAttrRefs() []*ast.AttrRef {
	if !dec.assertNewArray() {
		return nil
	}

	a := []*ast.AttrRef{}

	if dec.isEmptyArray() {
		return a
	}
	if dec.err != nil {
		return nil
	}

	for {
		elt := dec.decodeAttrRef()
		if dec.err != nil {
			return nil
		}

		a = append(a, elt)

		if dec.isEndArray() {
			break
		}
		if dec.err != nil {
			return nil
		}
	}

	return a
}

func (dec *decoder) decodeBasicLits() []*ast.BasicLit {
	if !dec.assertNewArray() {
		return nil
	}

	a := []*ast.BasicLit{}

	if dec.isEmptyArray() {
		return a
	}
	if dec.err != nil {
		return nil
	}

	for {
		elt := dec.decodeBasicLit()
		if dec.err != nil {
			return nil
		}

		a = append(a, elt)

		if dec.isEndArray() {
			break
		}
		if dec.err != nil {
			return nil
		}
	}

	return a
}

func (dec *decoder) decodeBinaryExprs() []*ast.BinaryExpr {
	if !dec.assertNewArray() {
		return nil
	}

	a := []*ast.BinaryExpr{}

	if dec.isEmptyArray() {
		return a
	}
	if dec.err != nil {
		return nil
	}

	for {
		elt := dec.decodeBinaryExpr()
		if dec.err != nil {
			return nil
		}

		a = append(a, elt)

		if dec.isEndArray() {
			break
		}
		if dec.err != nil {
			return nil
		}
	}

	return a
}

func (dec *decoder) decodeCallExprs() []*ast.CallExpr {
	if !dec.assertNewArray() {
		return nil
	}

	a := []*ast.CallExpr{}

	if dec.isEmptyArray() {
		return a
	}
	if dec.err != nil {
		return nil
	}

	for {
		elt := dec.decodeCallExpr()
		if dec.err != nil {
			return nil
		}

		a = append(a, elt)

		if dec.isEndArray() {
			break
		}
		if dec.err != nil {
			return nil
		}
	}

	return a
}

func (dec *decoder) decodeClassLits() []*ast.ClassLit {
	if !dec.assertNewArray() {
		return nil
	}

	a := []*ast.ClassLit{}

	if dec.isEmptyArray() {
		return a
	}
	if dec.err != nil {
		return nil
	}

	for {
		elt := dec.decodeClassLit()
		if dec.err != nil {
			return nil
		}

		a = append(a, elt)

		if dec.isEndArray() {
			break
		}
		if dec.err != nil {
			return nil
		}
	}

	return a
}

func (dec *decoder) decodeConstructorCallExprs() []*ast.ConstructorCallExpr {
	if !dec.assertNewArray() {
		return nil
	}

	a := []*ast.ConstructorCallExpr{}

	if dec.isEmptyArray() {
		return a
	}
	if dec.err != nil {
		return nil
	}

	for {
		elt := dec.decodeConstructorCallExpr()
		if dec.err != nil {
			return nil
		}

		a = append(a, elt)

		if dec.isEndArray() {
			break
		}
		if dec.err != nil {
			return nil
		}
	}

	return a
}

func (dec *decoder) decodeFuncLits() []*ast.FuncLit {
	if !dec.assertNewArray() {
		return nil
	}

	a := []*ast.FuncLit{}

	if dec.isEmptyArray() {
		return a
	}
	if dec.err != nil {
		return nil
	}

	for {
		elt := dec.decodeFuncLit()
		if dec.err != nil {
			return nil
		}

		a = append(a, elt)

		if dec.isEndArray() {
			break
		}
		if dec.err != nil {
			return nil
		}
	}

	return a
}

func (dec *decoder) decodeIdents() []*ast.Ident {
	if !dec.assertNewArray() {
		return nil
	}

	a := []*ast.Ident{}

	if dec.isEmptyArray() {
		return a
	}
	if dec.err != nil {
		return nil
	}

	for {
		elt := dec.decodeIdent()
		if dec.err != nil {
			return nil
		}

		a = append(a, elt)

		if dec.isEndArray() {
			break
		}
		if dec.err != nil {
			return nil
		}
	}

	return a
}

func (dec *decoder) decodeIncDecExprs() []*ast.IncDecExpr {
	if !dec.assertNewArray() {
		return nil
	}

	a := []*ast.IncDecExpr{}

	if dec.isEmptyArray() {
		return a
	}
	if dec.err != nil {
		return nil
	}

	for {
		elt := dec.decodeIncDecExpr()
		if dec.err != nil {
			return nil
		}

		a = append(a, elt)

		if dec.isEndArray() {
			break
		}
		if dec.err != nil {
			return nil
		}
	}

	return a
}

func (dec *decoder) decodeIndexExprs() []*ast.IndexExpr {
	if !dec.assertNewArray() {
		return nil
	}

	a := []*ast.IndexExpr{}

	if dec.isEmptyArray() {
		return a
	}
	if dec.err != nil {
		return nil
	}

	for {
		elt := dec.decodeIndexExpr()
		if dec.err != nil {
			return nil
		}

		a = append(a, elt)

		if dec.isEndArray() {
			break
		}
		if dec.err != nil {
			return nil
		}
	}

	return a
}

func (dec *decoder) decodeStructTypes() []*ast.StructType {
	if !dec.assertNewArray() {
		return nil
	}

	a := []*ast.StructType{}

	if dec.isEmptyArray() {
		return a
	}
	if dec.err != nil {
		return nil
	}

	for {
		elt := dec.decodeStructType()
		if dec.err != nil {
			return nil
		}

		a = append(a, elt)

		if dec.isEndArray() {
			break
		}
		if dec.err != nil {
			return nil
		}
	}

	return a
}

func (dec *decoder) decodeTernaryExprs() []*ast.TernaryExpr {
	if !dec.assertNewArray() {
		return nil
	}

	a := []*ast.TernaryExpr{}

	if dec.isEmptyArray() {
		return a
	}
	if dec.err != nil {
		return nil
	}

	for {
		elt := dec.decodeTernaryExpr()
		if dec.err != nil {
			return nil
		}

		a = append(a, elt)

		if dec.isEndArray() {
			break
		}
		if dec.err != nil {
			return nil
		}
	}

	return a
}

func (dec *decoder) decodeUnaryExprs() []*ast.UnaryExpr {
	if !dec.assertNewArray() {
		return nil
	}

	a := []*ast.UnaryExpr{}

	if dec.isEmptyArray() {
		return a
	}
	if dec.err != nil {
		return nil
	}

	for {
		elt := dec.decodeUnaryExpr()
		if dec.err != nil {
			return nil
		}

		a = append(a, elt)

		if dec.isEndArray() {
			break
		}
		if dec.err != nil {
			return nil
		}
	}

	return a
}

func (dec *decoder) decodeValueSpecs() []*ast.ValueSpec {
	if !dec.assertNewArray() {
		return nil
	}

	a := []*ast.ValueSpec{}

	if dec.isEmptyArray() {
		return a
	}
	if dec.err != nil {
		return nil
	}

	for {
		elt := dec.decodeValueSpec()
		if dec.err != nil {
			return nil
		}

		a = append(a, elt)

		if dec.isEndArray() {
			break
		}
		if dec.err != nil {
			return nil
		}
	}

	return a
}

func (dec *decoder) decodeStmt() ast.Stmt {
	if !dec.assertNewObject() {
		return nil
	}

	// Expression cannot be an empty object because ast.Stmt is an interface
	// and we need the value corresponding to the "statement_name" to allocate
	// the appropriate type.
	if dec.isEmptyObject() {
		dec.err = errors.New("statement object cannot be empty")
		return nil
	}
	if dec.err != nil {
		return nil
	}
	stmtName := dec.extractFirstKey("statement_name")
	if dec.err != nil {
		return nil
	}
	if dec.isEndObject() {
		dec.err = errors.New("statement object cannot be empty")
		return nil
	}

	// Since the beginning of the object has already been consumed, we need
	// special methods for only decoding the attributes.

	var stmt ast.Stmt
	switch stmtName {

	case token.AssignStmtName:
		stmt = dec.decodeAssignStmtAttrs()

	case token.DeclStmtName:
		stmt = dec.decodeDeclStmtAttrs()

	case token.ExprStmtName:
		stmt = dec.decodeExprStmtAttrs()

	case token.IfStmtName:
		stmt = dec.decodeIfStmtAttrs()

	case token.LoopStmtName:
		stmt = dec.decodeLoopStmtAttrs()

	case token.OtherStmtName:
		stmt = dec.decodeOtherStmtAttrs()

	case token.RangeLoopStmtName:
		stmt = dec.decodeRangeLoopStmtAttrs()

	case token.ReturnStmtName:
		stmt = dec.decodeReturnStmtAttrs()

	case token.SwitchStmtName:
		stmt = dec.decodeSwitchStmtAttrs()

	case token.ThrowStmtName:
		stmt = dec.decodeThrowStmtAttrs()

	case token.TryStmtName:
		stmt = dec.decodeTryStmtAttrs()

	default:
		dec.err = fmt.Errorf("unknown statement '%s'", stmtName)
		return nil
	}
	if dec.err != nil {
		return nil
	}
	return stmt
}

func (dec *decoder) decodeAssignStmt() *ast.AssignStmt {
	if !dec.assertNewObject() {
		return nil
	}
	if dec.isEmptyObject() {
		dec.err = errors.New("AssignStmt object cannot be empty")
		return nil
	}
	if dec.err != nil {
		return nil
	}
	return dec.decodeAssignStmtAttrs()
}

func (dec *decoder) decodeAssignStmtAttrs() *ast.AssignStmt {
	stmt := ast.AssignStmt{}
	stmt.StmtName = token.AssignStmtName
	for {
		key, err := dec.scan.nextKey()
		if err != nil {
			if err == io.EOF {
				break
			}
			dec.err = err
			return nil
		}
		if key == "" {
			dec.err = errors.New("empty key")
			return nil
		}

		val, tok, err := dec.scan.nextValue()

		if err != nil {
			dec.err = err
			return nil
		}

		if tok != scanNullVal {
			switch key {

			case "statement_name":

				if tok != scanStringLit {
					dec.err = fmt.Errorf("expected 'String literal', found '%v'", tok)
					return nil
				}
				stmt.StmtName, dec.err = dec.unmarshalString(val)

			case "left_hand_side":

				dec.scan.back()

				stmt.LHS = dec.decodeExprs()

			case "right_hand_side":

				dec.scan.back()

				stmt.RHS = dec.decodeExprs()

			case "line":

				if tok != scanInt64Lit {
					dec.err = fmt.Errorf("expected 'Int64 literal', found '%v'", tok)
					return nil
				}
				stmt.Line, dec.err = dec.unmarshalInt64(val)

			default:
				dec.err = fmt.Errorf("unexpected key '%s' for AssignStmt object", key)
			}
		}

		if dec.err != nil {
			return nil
		}

		if dec.isEndObject() {
			break
		}
		if err != nil {
			return nil
		}
	}
	return &stmt
}

func (dec *decoder) decodeDeclStmt() *ast.DeclStmt {
	if !dec.assertNewObject() {
		return nil
	}
	if dec.isEmptyObject() {
		dec.err = errors.New("DeclStmt object cannot be empty")
		return nil
	}
	if dec.err != nil {
		return nil
	}
	return dec.decodeDeclStmtAttrs()
}

func (dec *decoder) decodeDeclStmtAttrs() *ast.DeclStmt {
	stmt := ast.DeclStmt{}
	stmt.StmtName = token.DeclStmtName
	for {
		key, err := dec.scan.nextKey()
		if err != nil {
			if err == io.EOF {
				break
			}
			dec.err = err
			return nil
		}
		if key == "" {
			dec.err = errors.New("empty key")
			return nil
		}

		val, tok, err := dec.scan.nextValue()

		if err != nil {
			dec.err = err
			return nil
		}

		if tok != scanNullVal {
			switch key {

			case "statement_name":

				if tok != scanStringLit {
					dec.err = fmt.Errorf("expected 'String literal', found '%v'", tok)
					return nil
				}
				stmt.StmtName, dec.err = dec.unmarshalString(val)

			case "left_hand_side":

				dec.scan.back()

				stmt.LHS = dec.decodeExprs()

			case "right_hand_side":

				dec.scan.back()

				stmt.RHS = dec.decodeExprs()

			case "line":

				if tok != scanInt64Lit {
					dec.err = fmt.Errorf("expected 'Int64 literal', found '%v'", tok)
					return nil
				}
				stmt.Line, dec.err = dec.unmarshalInt64(val)

			case "kind":

				if tok != scanStringLit {
					dec.err = fmt.Errorf("expected 'String literal', found '%v'", tok)
					return nil
				}
				stmt.Kind, dec.err = dec.unmarshalString(val)

			default:
				dec.err = fmt.Errorf("unexpected key '%s' for DeclStmt object", key)
			}
		}

		if dec.err != nil {
			return nil
		}

		if dec.isEndObject() {
			break
		}
		if err != nil {
			return nil
		}
	}
	return &stmt
}

func (dec *decoder) decodeExprStmt() *ast.ExprStmt {
	if !dec.assertNewObject() {
		return nil
	}
	if dec.isEmptyObject() {
		dec.err = errors.New("ExprStmt object cannot be empty")
		return nil
	}
	if dec.err != nil {
		return nil
	}
	return dec.decodeExprStmtAttrs()
}

func (dec *decoder) decodeExprStmtAttrs() *ast.ExprStmt {
	stmt := ast.ExprStmt{}
	stmt.StmtName = token.ExprStmtName
	for {
		key, err := dec.scan.nextKey()
		if err != nil {
			if err == io.EOF {
				break
			}
			dec.err = err
			return nil
		}
		if key == "" {
			dec.err = errors.New("empty key")
			return nil
		}

		val, tok, err := dec.scan.nextValue()

		if err != nil {
			dec.err = err
			return nil
		}

		if tok != scanNullVal {
			switch key {

			case "statement_name":

				if tok != scanStringLit {
					dec.err = fmt.Errorf("expected 'String literal', found '%v'", tok)
					return nil
				}
				stmt.StmtName, dec.err = dec.unmarshalString(val)

			case "expression":

				dec.scan.back()

				stmt.X = dec.decodeExpr()

			default:
				dec.err = fmt.Errorf("unexpected key '%s' for ExprStmt object", key)
			}
		}

		if dec.err != nil {
			return nil
		}

		if dec.isEndObject() {
			break
		}
		if err != nil {
			return nil
		}
	}
	return &stmt
}

func (dec *decoder) decodeIfStmt() *ast.IfStmt {
	if !dec.assertNewObject() {
		return nil
	}
	if dec.isEmptyObject() {
		dec.err = errors.New("IfStmt object cannot be empty")
		return nil
	}
	if dec.err != nil {
		return nil
	}
	return dec.decodeIfStmtAttrs()
}

func (dec *decoder) decodeIfStmtAttrs() *ast.IfStmt {
	stmt := ast.IfStmt{}
	stmt.StmtName = token.IfStmtName
	for {
		key, err := dec.scan.nextKey()
		if err != nil {
			if err == io.EOF {
				break
			}
			dec.err = err
			return nil
		}
		if key == "" {
			dec.err = errors.New("empty key")
			return nil
		}

		val, tok, err := dec.scan.nextValue()

		if err != nil {
			dec.err = err
			return nil
		}

		if tok != scanNullVal {
			switch key {

			case "statement_name":

				if tok != scanStringLit {
					dec.err = fmt.Errorf("expected 'String literal', found '%v'", tok)
					return nil
				}
				stmt.StmtName, dec.err = dec.unmarshalString(val)

			case "initialization":

				dec.scan.back()

				stmt.Init = dec.decodeStmt()

			case "condition":

				dec.scan.back()

				stmt.Cond = dec.decodeExpr()

			case "body":

				dec.scan.back()

				stmt.Body = dec.decodeStmts()

			case "else":

				dec.scan.back()

				stmt.Else = dec.decodeStmts()

			case "line":

				if tok != scanInt64Lit {
					dec.err = fmt.Errorf("expected 'Int64 literal', found '%v'", tok)
					return nil
				}
				stmt.Line, dec.err = dec.unmarshalInt64(val)

			default:
				dec.err = fmt.Errorf("unexpected key '%s' for IfStmt object", key)
			}
		}

		if dec.err != nil {
			return nil
		}

		if dec.isEndObject() {
			break
		}
		if err != nil {
			return nil
		}
	}
	return &stmt
}

func (dec *decoder) decodeLoopStmt() *ast.LoopStmt {
	if !dec.assertNewObject() {
		return nil
	}
	if dec.isEmptyObject() {
		dec.err = errors.New("LoopStmt object cannot be empty")
		return nil
	}
	if dec.err != nil {
		return nil
	}
	return dec.decodeLoopStmtAttrs()
}

func (dec *decoder) decodeLoopStmtAttrs() *ast.LoopStmt {
	stmt := ast.LoopStmt{}
	stmt.StmtName = token.LoopStmtName
	for {
		key, err := dec.scan.nextKey()
		if err != nil {
			if err == io.EOF {
				break
			}
			dec.err = err
			return nil
		}
		if key == "" {
			dec.err = errors.New("empty key")
			return nil
		}

		val, tok, err := dec.scan.nextValue()

		if err != nil {
			dec.err = err
			return nil
		}

		if tok != scanNullVal {
			switch key {

			case "statement_name":

				if tok != scanStringLit {
					dec.err = fmt.Errorf("expected 'String literal', found '%v'", tok)
					return nil
				}
				stmt.StmtName, dec.err = dec.unmarshalString(val)

			case "initialization":

				dec.scan.back()

				stmt.Init = dec.decodeStmts()

			case "condition":

				dec.scan.back()

				stmt.Cond = dec.decodeExpr()

			case "post_iteration_statement":

				dec.scan.back()

				stmt.Post = dec.decodeStmts()

			case "body":

				dec.scan.back()

				stmt.Body = dec.decodeStmts()

			case "else":

				dec.scan.back()

				stmt.Else = dec.decodeStmts()

			case "is_post_evaluated":

				if tok != scanBoolLit {
					dec.err = fmt.Errorf("expected 'Bool literal', found '%v'", tok)
					return nil
				}
				stmt.IsPostEval, dec.err = dec.unmarshalBool(val)

			case "line":

				if tok != scanInt64Lit {
					dec.err = fmt.Errorf("expected 'Int64 literal', found '%v'", tok)
					return nil
				}
				stmt.Line, dec.err = dec.unmarshalInt64(val)

			default:
				dec.err = fmt.Errorf("unexpected key '%s' for LoopStmt object", key)
			}
		}

		if dec.err != nil {
			return nil
		}

		if dec.isEndObject() {
			break
		}
		if err != nil {
			return nil
		}
	}
	return &stmt
}

func (dec *decoder) decodeOtherStmt() *ast.OtherStmt {
	if !dec.assertNewObject() {
		return nil
	}
	if dec.isEmptyObject() {
		dec.err = errors.New("OtherStmt object cannot be empty")
		return nil
	}
	if dec.err != nil {
		return nil
	}
	return dec.decodeOtherStmtAttrs()
}

func (dec *decoder) decodeOtherStmtAttrs() *ast.OtherStmt {
	stmt := ast.OtherStmt{}
	stmt.StmtName = token.OtherStmtName
	for {
		key, err := dec.scan.nextKey()
		if err != nil {
			if err == io.EOF {
				break
			}
			dec.err = err
			return nil
		}
		if key == "" {
			dec.err = errors.New("empty key")
			return nil
		}

		val, tok, err := dec.scan.nextValue()

		if err != nil {
			dec.err = err
			return nil
		}

		if tok != scanNullVal {
			switch key {

			case "statement_name":

				if tok != scanStringLit {
					dec.err = fmt.Errorf("expected 'String literal', found '%v'", tok)
					return nil
				}
				stmt.StmtName, dec.err = dec.unmarshalString(val)

			case "body":

				dec.scan.back()

				stmt.Body = dec.decodeStmts()

			case "line":

				if tok != scanInt64Lit {
					dec.err = fmt.Errorf("expected 'Int64 literal', found '%v'", tok)
					return nil
				}
				stmt.Line, dec.err = dec.unmarshalInt64(val)

			default:
				dec.err = fmt.Errorf("unexpected key '%s' for OtherStmt object", key)
			}
		}

		if dec.err != nil {
			return nil
		}

		if dec.isEndObject() {
			break
		}
		if err != nil {
			return nil
		}
	}
	return &stmt
}

func (dec *decoder) decodeRangeLoopStmt() *ast.RangeLoopStmt {
	if !dec.assertNewObject() {
		return nil
	}
	if dec.isEmptyObject() {
		dec.err = errors.New("RangeLoopStmt object cannot be empty")
		return nil
	}
	if dec.err != nil {
		return nil
	}
	return dec.decodeRangeLoopStmtAttrs()
}

func (dec *decoder) decodeRangeLoopStmtAttrs() *ast.RangeLoopStmt {
	stmt := ast.RangeLoopStmt{}
	stmt.StmtName = token.RangeLoopStmtName
	for {
		key, err := dec.scan.nextKey()
		if err != nil {
			if err == io.EOF {
				break
			}
			dec.err = err
			return nil
		}
		if key == "" {
			dec.err = errors.New("empty key")
			return nil
		}

		val, tok, err := dec.scan.nextValue()

		if err != nil {
			dec.err = err
			return nil
		}

		if tok != scanNullVal {
			switch key {

			case "statement_name":

				if tok != scanStringLit {
					dec.err = fmt.Errorf("expected 'String literal', found '%v'", tok)
					return nil
				}
				stmt.StmtName, dec.err = dec.unmarshalString(val)

			case "variables":

				dec.scan.back()

				stmt.Vars = dec.decodeExprs()

			case "iterable":

				dec.scan.back()

				stmt.Iterable = dec.decodeExpr()

			case "body":

				dec.scan.back()

				stmt.Body = dec.decodeStmts()

			case "line":

				if tok != scanInt64Lit {
					dec.err = fmt.Errorf("expected 'Int64 literal', found '%v'", tok)
					return nil
				}
				stmt.Line, dec.err = dec.unmarshalInt64(val)

			default:
				dec.err = fmt.Errorf("unexpected key '%s' for RangeLoopStmt object", key)
			}
		}

		if dec.err != nil {
			return nil
		}

		if dec.isEndObject() {
			break
		}
		if err != nil {
			return nil
		}
	}
	return &stmt
}

func (dec *decoder) decodeReturnStmt() *ast.ReturnStmt {
	if !dec.assertNewObject() {
		return nil
	}
	if dec.isEmptyObject() {
		dec.err = errors.New("ReturnStmt object cannot be empty")
		return nil
	}
	if dec.err != nil {
		return nil
	}
	return dec.decodeReturnStmtAttrs()
}

func (dec *decoder) decodeReturnStmtAttrs() *ast.ReturnStmt {
	stmt := ast.ReturnStmt{}
	stmt.StmtName = token.ReturnStmtName
	for {
		key, err := dec.scan.nextKey()
		if err != nil {
			if err == io.EOF {
				break
			}
			dec.err = err
			return nil
		}
		if key == "" {
			dec.err = errors.New("empty key")
			return nil
		}

		val, tok, err := dec.scan.nextValue()

		if err != nil {
			dec.err = err
			return nil
		}

		if tok != scanNullVal {
			switch key {

			case "statement_name":

				if tok != scanStringLit {
					dec.err = fmt.Errorf("expected 'String literal', found '%v'", tok)
					return nil
				}
				stmt.StmtName, dec.err = dec.unmarshalString(val)

			case "results":

				dec.scan.back()

				stmt.Results = dec.decodeExprs()

			case "line":

				if tok != scanInt64Lit {
					dec.err = fmt.Errorf("expected 'Int64 literal', found '%v'", tok)
					return nil
				}
				stmt.Line, dec.err = dec.unmarshalInt64(val)

			default:
				dec.err = fmt.Errorf("unexpected key '%s' for ReturnStmt object", key)
			}
		}

		if dec.err != nil {
			return nil
		}

		if dec.isEndObject() {
			break
		}
		if err != nil {
			return nil
		}
	}
	return &stmt
}

func (dec *decoder) decodeSwitchStmt() *ast.SwitchStmt {
	if !dec.assertNewObject() {
		return nil
	}
	if dec.isEmptyObject() {
		dec.err = errors.New("SwitchStmt object cannot be empty")
		return nil
	}
	if dec.err != nil {
		return nil
	}
	return dec.decodeSwitchStmtAttrs()
}

func (dec *decoder) decodeSwitchStmtAttrs() *ast.SwitchStmt {
	stmt := ast.SwitchStmt{}
	stmt.StmtName = token.SwitchStmtName
	for {
		key, err := dec.scan.nextKey()
		if err != nil {
			if err == io.EOF {
				break
			}
			dec.err = err
			return nil
		}
		if key == "" {
			dec.err = errors.New("empty key")
			return nil
		}

		val, tok, err := dec.scan.nextValue()

		if err != nil {
			dec.err = err
			return nil
		}

		if tok != scanNullVal {
			switch key {

			case "statement_name":

				if tok != scanStringLit {
					dec.err = fmt.Errorf("expected 'String literal', found '%v'", tok)
					return nil
				}
				stmt.StmtName, dec.err = dec.unmarshalString(val)

			case "initialization":

				dec.scan.back()

				stmt.Init = dec.decodeStmt()

			case "condition":

				dec.scan.back()

				stmt.Cond = dec.decodeExpr()

			case "case_clauses":

				dec.scan.back()

				stmt.CaseClauses = dec.decodeCaseClauses()

			case "default":

				dec.scan.back()

				stmt.Default = dec.decodeStmts()

			default:
				dec.err = fmt.Errorf("unexpected key '%s' for SwitchStmt object", key)
			}
		}

		if dec.err != nil {
			return nil
		}

		if dec.isEndObject() {
			break
		}
		if err != nil {
			return nil
		}
	}
	return &stmt
}

func (dec *decoder) decodeThrowStmt() *ast.ThrowStmt {
	if !dec.assertNewObject() {
		return nil
	}
	if dec.isEmptyObject() {
		dec.err = errors.New("ThrowStmt object cannot be empty")
		return nil
	}
	if dec.err != nil {
		return nil
	}
	return dec.decodeThrowStmtAttrs()
}

func (dec *decoder) decodeThrowStmtAttrs() *ast.ThrowStmt {
	stmt := ast.ThrowStmt{}
	stmt.StmtName = token.ThrowStmtName
	for {
		key, err := dec.scan.nextKey()
		if err != nil {
			if err == io.EOF {
				break
			}
			dec.err = err
			return nil
		}
		if key == "" {
			dec.err = errors.New("empty key")
			return nil
		}

		val, tok, err := dec.scan.nextValue()

		if err != nil {
			dec.err = err
			return nil
		}

		if tok != scanNullVal {
			switch key {

			case "statement_name":

				if tok != scanStringLit {
					dec.err = fmt.Errorf("expected 'String literal', found '%v'", tok)
					return nil
				}
				stmt.StmtName, dec.err = dec.unmarshalString(val)

			case "expression":

				dec.scan.back()

				stmt.X = dec.decodeExpr()

			default:
				dec.err = fmt.Errorf("unexpected key '%s' for ThrowStmt object", key)
			}
		}

		if dec.err != nil {
			return nil
		}

		if dec.isEndObject() {
			break
		}
		if err != nil {
			return nil
		}
	}
	return &stmt
}

func (dec *decoder) decodeTryStmt() *ast.TryStmt {
	if !dec.assertNewObject() {
		return nil
	}
	if dec.isEmptyObject() {
		dec.err = errors.New("TryStmt object cannot be empty")
		return nil
	}
	if dec.err != nil {
		return nil
	}
	return dec.decodeTryStmtAttrs()
}

func (dec *decoder) decodeTryStmtAttrs() *ast.TryStmt {
	stmt := ast.TryStmt{}
	stmt.StmtName = token.TryStmtName
	for {
		key, err := dec.scan.nextKey()
		if err != nil {
			if err == io.EOF {
				break
			}
			dec.err = err
			return nil
		}
		if key == "" {
			dec.err = errors.New("empty key")
			return nil
		}

		val, tok, err := dec.scan.nextValue()

		if err != nil {
			dec.err = err
			return nil
		}

		if tok != scanNullVal {
			switch key {

			case "statement_name":

				if tok != scanStringLit {
					dec.err = fmt.Errorf("expected 'String literal', found '%v'", tok)
					return nil
				}
				stmt.StmtName, dec.err = dec.unmarshalString(val)

			case "body":

				dec.scan.back()

				stmt.Body = dec.decodeStmts()

			case "catch_clauses":

				dec.scan.back()

				stmt.CatchClauses = dec.decodeCatchClauses()

			case "finally":

				dec.scan.back()

				stmt.Finally = dec.decodeStmts()

			default:
				dec.err = fmt.Errorf("unexpected key '%s' for TryStmt object", key)
			}
		}

		if dec.err != nil {
			return nil
		}

		if dec.isEndObject() {
			break
		}
		if err != nil {
			return nil
		}
	}
	return &stmt
}

func (dec *decoder) decodeAssignStmts() []*ast.AssignStmt {
	if !dec.assertNewArray() {
		return nil
	}

	a := []*ast.AssignStmt{}

	if dec.isEmptyArray() {
		return a
	}
	if dec.err != nil {
		return nil
	}

	for {
		elt := dec.decodeAssignStmt()
		if dec.err != nil {
			return nil
		}

		a = append(a, elt)

		if dec.isEndArray() {
			break
		}
		if dec.err != nil {
			return nil
		}
	}

	return a
}

func (dec *decoder) decodeDeclStmts() []*ast.DeclStmt {
	if !dec.assertNewArray() {
		return nil
	}

	a := []*ast.DeclStmt{}

	if dec.isEmptyArray() {
		return a
	}
	if dec.err != nil {
		return nil
	}

	for {
		elt := dec.decodeDeclStmt()
		if dec.err != nil {
			return nil
		}

		a = append(a, elt)

		if dec.isEndArray() {
			break
		}
		if dec.err != nil {
			return nil
		}
	}

	return a
}

func (dec *decoder) decodeExprStmts() []*ast.ExprStmt {
	if !dec.assertNewArray() {
		return nil
	}

	a := []*ast.ExprStmt{}

	if dec.isEmptyArray() {
		return a
	}
	if dec.err != nil {
		return nil
	}

	for {
		elt := dec.decodeExprStmt()
		if dec.err != nil {
			return nil
		}

		a = append(a, elt)

		if dec.isEndArray() {
			break
		}
		if dec.err != nil {
			return nil
		}
	}

	return a
}

func (dec *decoder) decodeIfStmts() []*ast.IfStmt {
	if !dec.assertNewArray() {
		return nil
	}

	a := []*ast.IfStmt{}

	if dec.isEmptyArray() {
		return a
	}
	if dec.err != nil {
		return nil
	}

	for {
		elt := dec.decodeIfStmt()
		if dec.err != nil {
			return nil
		}

		a = append(a, elt)

		if dec.isEndArray() {
			break
		}
		if dec.err != nil {
			return nil
		}
	}

	return a
}

func (dec *decoder) decodeLoopStmts() []*ast.LoopStmt {
	if !dec.assertNewArray() {
		return nil
	}

	a := []*ast.LoopStmt{}

	if dec.isEmptyArray() {
		return a
	}
	if dec.err != nil {
		return nil
	}

	for {
		elt := dec.decodeLoopStmt()
		if dec.err != nil {
			return nil
		}

		a = append(a, elt)

		if dec.isEndArray() {
			break
		}
		if dec.err != nil {
			return nil
		}
	}

	return a
}

func (dec *decoder) decodeOtherStmts() []*ast.OtherStmt {
	if !dec.assertNewArray() {
		return nil
	}

	a := []*ast.OtherStmt{}

	if dec.isEmptyArray() {
		return a
	}
	if dec.err != nil {
		return nil
	}

	for {
		elt := dec.decodeOtherStmt()
		if dec.err != nil {
			return nil
		}

		a = append(a, elt)

		if dec.isEndArray() {
			break
		}
		if dec.err != nil {
			return nil
		}
	}

	return a
}

func (dec *decoder) decodeRangeLoopStmts() []*ast.RangeLoopStmt {
	if !dec.assertNewArray() {
		return nil
	}

	a := []*ast.RangeLoopStmt{}

	if dec.isEmptyArray() {
		return a
	}
	if dec.err != nil {
		return nil
	}

	for {
		elt := dec.decodeRangeLoopStmt()
		if dec.err != nil {
			return nil
		}

		a = append(a, elt)

		if dec.isEndArray() {
			break
		}
		if dec.err != nil {
			return nil
		}
	}

	return a
}

func (dec *decoder) decodeReturnStmts() []*ast.ReturnStmt {
	if !dec.assertNewArray() {
		return nil
	}

	a := []*ast.ReturnStmt{}

	if dec.isEmptyArray() {
		return a
	}
	if dec.err != nil {
		return nil
	}

	for {
		elt := dec.decodeReturnStmt()
		if dec.err != nil {
			return nil
		}

		a = append(a, elt)

		if dec.isEndArray() {
			break
		}
		if dec.err != nil {
			return nil
		}
	}

	return a
}

func (dec *decoder) decodeSwitchStmts() []*ast.SwitchStmt {
	if !dec.assertNewArray() {
		return nil
	}

	a := []*ast.SwitchStmt{}

	if dec.isEmptyArray() {
		return a
	}
	if dec.err != nil {
		return nil
	}

	for {
		elt := dec.decodeSwitchStmt()
		if dec.err != nil {
			return nil
		}

		a = append(a, elt)

		if dec.isEndArray() {
			break
		}
		if dec.err != nil {
			return nil
		}
	}

	return a
}

func (dec *decoder) decodeThrowStmts() []*ast.ThrowStmt {
	if !dec.assertNewArray() {
		return nil
	}

	a := []*ast.ThrowStmt{}

	if dec.isEmptyArray() {
		return a
	}
	if dec.err != nil {
		return nil
	}

	for {
		elt := dec.decodeThrowStmt()
		if dec.err != nil {
			return nil
		}

		a = append(a, elt)

		if dec.isEndArray() {
			break
		}
		if dec.err != nil {
			return nil
		}
	}

	return a
}

func (dec *decoder) decodeTryStmts() []*ast.TryStmt {
	if !dec.assertNewArray() {
		return nil
	}

	a := []*ast.TryStmt{}

	if dec.isEmptyArray() {
		return a
	}
	if dec.err != nil {
		return nil
	}

	for {
		elt := dec.decodeTryStmt()
		if dec.err != nil {
			return nil
		}

		a = append(a, elt)

		if dec.isEndArray() {
			break
		}
		if dec.err != nil {
			return nil
		}
	}

	return a
}

func (dec *decoder) decodeArrayType() *ast.ArrayType {
	if dec.isNull() {
		return nil
	}
	if !dec.assertNewObject() {
		return nil
	}
	if dec.isEmptyObject() {
		return nil
	}
	if dec.err != nil {
		return nil
	}

	any := ast.ArrayType{}
	for {
		key, err := dec.scan.nextKey()
		if err != nil {
			if err == io.EOF {
				break
			}
			dec.err = err
			return nil
		}
		if key == "" {
			dec.err = errors.New("empty key")
			return nil
		}

		_, tok, err := dec.scan.nextValue()

		if err != nil {
			dec.err = err
			return nil
		}

		if tok != scanNullVal {
			switch key {

			case "dimensions":

				dec.scan.back()

				any.Dims = dec.decodeInt64s()

			case "element_type":

				dec.scan.back()

				any.Elt = dec.decodeExpr()

			default:
				dec.err = fmt.Errorf("unexpected key '%s' for ArrayType object", key)
			}
		}

		if dec.err != nil {
			return nil
		}

		if dec.isEndObject() {
			break
		}
		if err != nil {
			return nil
		}
	}
	return &any
}

func (dec *decoder) decodeAttr() *ast.Attr {
	if dec.isNull() {
		return nil
	}
	if !dec.assertNewObject() {
		return nil
	}
	if dec.isEmptyObject() {
		return nil
	}
	if dec.err != nil {
		return nil
	}

	any := ast.Attr{}
	for {
		key, err := dec.scan.nextKey()
		if err != nil {
			if err == io.EOF {
				break
			}
			dec.err = err
			return nil
		}
		if key == "" {
			dec.err = errors.New("empty key")
			return nil
		}

		val, tok, err := dec.scan.nextValue()

		if err != nil {
			dec.err = err
			return nil
		}

		if tok != scanNullVal {
			switch key {

			case "doc":

				dec.scan.back()

				any.Doc = dec.decodeStrings()

			case "name":

				if tok != scanStringLit {
					dec.err = fmt.Errorf("expected 'String literal', found '%v'", tok)
					return nil
				}
				any.Name, dec.err = dec.unmarshalString(val)

			case "type":

				if tok != scanStringLit {
					dec.err = fmt.Errorf("expected 'String literal', found '%v'", tok)
					return nil
				}
				any.Type, dec.err = dec.unmarshalString(val)

			case "value":

				if tok != scanStringLit {
					dec.err = fmt.Errorf("expected 'String literal', found '%v'", tok)
					return nil
				}
				any.Value, dec.err = dec.unmarshalString(val)

			case "is_pointer":

				if tok != scanBoolLit {
					dec.err = fmt.Errorf("expected 'Bool literal', found '%v'", tok)
					return nil
				}
				any.IsPointer, dec.err = dec.unmarshalBool(val)

			case "visibility":

				if tok != scanStringLit {
					dec.err = fmt.Errorf("expected 'String literal', found '%v'", tok)
					return nil
				}
				any.Visibility, dec.err = dec.unmarshalString(val)

			case "constant":

				if tok != scanBoolLit {
					dec.err = fmt.Errorf("expected 'Bool literal', found '%v'", tok)
					return nil
				}
				any.Constant, dec.err = dec.unmarshalBool(val)

			case "static":

				if tok != scanBoolLit {
					dec.err = fmt.Errorf("expected 'Bool literal', found '%v'", tok)
					return nil
				}
				any.Static, dec.err = dec.unmarshalBool(val)

			default:
				dec.err = fmt.Errorf("unexpected key '%s' for Attr object", key)
			}
		}

		if dec.err != nil {
			return nil
		}

		if dec.isEndObject() {
			break
		}
		if err != nil {
			return nil
		}
	}
	return &any
}

func (dec *decoder) decodeClassDecl() *ast.ClassDecl {
	if dec.isNull() {
		return nil
	}
	if !dec.assertNewObject() {
		return nil
	}
	if dec.isEmptyObject() {
		return nil
	}
	if dec.err != nil {
		return nil
	}

	any := ast.ClassDecl{}
	for {
		key, err := dec.scan.nextKey()
		if err != nil {
			if err == io.EOF {
				break
			}
			dec.err = err
			return nil
		}
		if key == "" {
			dec.err = errors.New("empty key")
			return nil
		}

		val, tok, err := dec.scan.nextValue()

		if err != nil {
			dec.err = err
			return nil
		}

		if tok != scanNullVal {
			switch key {

			case "doc":

				dec.scan.back()

				any.Doc = dec.decodeStrings()

			case "name":

				if tok != scanStringLit {
					dec.err = fmt.Errorf("expected 'String literal', found '%v'", tok)
					return nil
				}
				any.Name, dec.err = dec.unmarshalString(val)

			case "visibility":

				if tok != scanStringLit {
					dec.err = fmt.Errorf("expected 'String literal', found '%v'", tok)
					return nil
				}
				any.Visibility, dec.err = dec.unmarshalString(val)

			case "extended_classes":

				dec.scan.back()

				any.ExtendedClasses = dec.decodeClassRefs()

			case "implemented_interfaces":

				dec.scan.back()

				any.ImplementedInterfaces = dec.decodeInterfaceRefs()

			case "attributes":

				dec.scan.back()

				any.Attrs = dec.decodeAttrs()

			case "constructors":

				dec.scan.back()

				any.Constructors = dec.decodeConstructorDecls()

			case "destructors":

				dec.scan.back()

				any.Destructors = dec.decodeDestructorDecls()

			case "methods":

				dec.scan.back()

				any.Methods = dec.decodeMethodDecls()

			case "nested_classes":

				dec.scan.back()

				any.NestedClasses = dec.decodeClassDecls()

			case "mixins":

				dec.scan.back()

				any.Mixins = dec.decodeTraitRefs()

			default:
				dec.err = fmt.Errorf("unexpected key '%s' for ClassDecl object", key)
			}
		}

		if dec.err != nil {
			return nil
		}

		if dec.isEndObject() {
			break
		}
		if err != nil {
			return nil
		}
	}
	return &any
}

func (dec *decoder) decodeClassRef() *ast.ClassRef {
	if dec.isNull() {
		return nil
	}
	if !dec.assertNewObject() {
		return nil
	}
	if dec.isEmptyObject() {
		return nil
	}
	if dec.err != nil {
		return nil
	}

	any := ast.ClassRef{}
	for {
		key, err := dec.scan.nextKey()
		if err != nil {
			if err == io.EOF {
				break
			}
			dec.err = err
			return nil
		}
		if key == "" {
			dec.err = errors.New("empty key")
			return nil
		}

		val, tok, err := dec.scan.nextValue()

		if err != nil {
			dec.err = err
			return nil
		}

		if tok != scanNullVal {
			switch key {

			case "namespace":

				if tok != scanStringLit {
					dec.err = fmt.Errorf("expected 'String literal', found '%v'", tok)
					return nil
				}
				any.Namespace, dec.err = dec.unmarshalString(val)

			case "class_name":

				if tok != scanStringLit {
					dec.err = fmt.Errorf("expected 'String literal', found '%v'", tok)
					return nil
				}
				any.ClassName, dec.err = dec.unmarshalString(val)

			default:
				dec.err = fmt.Errorf("unexpected key '%s' for ClassRef object", key)
			}
		}

		if dec.err != nil {
			return nil
		}

		if dec.isEndObject() {
			break
		}
		if err != nil {
			return nil
		}
	}
	return &any
}

func (dec *decoder) decodeConstant() *ast.Constant {
	if dec.isNull() {
		return nil
	}
	if !dec.assertNewObject() {
		return nil
	}
	if dec.isEmptyObject() {
		return nil
	}
	if dec.err != nil {
		return nil
	}

	any := ast.Constant{}
	for {
		key, err := dec.scan.nextKey()
		if err != nil {
			if err == io.EOF {
				break
			}
			dec.err = err
			return nil
		}
		if key == "" {
			dec.err = errors.New("empty key")
			return nil
		}

		val, tok, err := dec.scan.nextValue()

		if err != nil {
			dec.err = err
			return nil
		}

		if tok != scanNullVal {
			switch key {

			case "doc":

				dec.scan.back()

				any.Doc = dec.decodeStrings()

			case "name":

				if tok != scanStringLit {
					dec.err = fmt.Errorf("expected 'String literal', found '%v'", tok)
					return nil
				}
				any.Name, dec.err = dec.unmarshalString(val)

			case "type":

				if tok != scanStringLit {
					dec.err = fmt.Errorf("expected 'String literal', found '%v'", tok)
					return nil
				}
				any.Type, dec.err = dec.unmarshalString(val)

			case "value":

				if tok != scanStringLit {
					dec.err = fmt.Errorf("expected 'String literal', found '%v'", tok)
					return nil
				}
				any.Value, dec.err = dec.unmarshalString(val)

			case "is_pointer":

				if tok != scanBoolLit {
					dec.err = fmt.Errorf("expected 'Bool literal', found '%v'", tok)
					return nil
				}
				any.IsPointer, dec.err = dec.unmarshalBool(val)

			case "visibility":

				if tok != scanStringLit {
					dec.err = fmt.Errorf("expected 'String literal', found '%v'", tok)
					return nil
				}
				any.Visibility, dec.err = dec.unmarshalString(val)

			default:
				dec.err = fmt.Errorf("unexpected key '%s' for Constant object", key)
			}
		}

		if dec.err != nil {
			return nil
		}

		if dec.isEndObject() {
			break
		}
		if err != nil {
			return nil
		}
	}
	return &any
}

func (dec *decoder) decodeConstructorDecl() *ast.ConstructorDecl {
	if dec.isNull() {
		return nil
	}
	if !dec.assertNewObject() {
		return nil
	}
	if dec.isEmptyObject() {
		return nil
	}
	if dec.err != nil {
		return nil
	}

	any := ast.ConstructorDecl{}
	for {
		key, err := dec.scan.nextKey()
		if err != nil {
			if err == io.EOF {
				break
			}
			dec.err = err
			return nil
		}
		if key == "" {
			dec.err = errors.New("empty key")
			return nil
		}

		val, tok, err := dec.scan.nextValue()

		if err != nil {
			dec.err = err
			return nil
		}

		if tok != scanNullVal {
			switch key {

			case "doc":

				dec.scan.back()

				any.Doc = dec.decodeStrings()

			case "name":

				if tok != scanStringLit {
					dec.err = fmt.Errorf("expected 'String literal', found '%v'", tok)
					return nil
				}
				any.Name, dec.err = dec.unmarshalString(val)

			case "parameters":

				dec.scan.back()

				any.Params = dec.decodeFields()

			case "body":

				dec.scan.back()

				any.Body = dec.decodeStmts()

			case "visibility":

				if tok != scanStringLit {
					dec.err = fmt.Errorf("expected 'String literal', found '%v'", tok)
					return nil
				}
				any.Visibility, dec.err = dec.unmarshalString(val)

			case "loc":

				if tok != scanInt64Lit {
					dec.err = fmt.Errorf("expected 'Int64 literal', found '%v'", tok)
					return nil
				}
				any.LoC, dec.err = dec.unmarshalInt64(val)

			default:
				dec.err = fmt.Errorf("unexpected key '%s' for ConstructorDecl object", key)
			}
		}

		if dec.err != nil {
			return nil
		}

		if dec.isEndObject() {
			break
		}
		if err != nil {
			return nil
		}
	}
	return &any
}

func (dec *decoder) decodeDestructorDecl() *ast.DestructorDecl {
	if dec.isNull() {
		return nil
	}
	if !dec.assertNewObject() {
		return nil
	}
	if dec.isEmptyObject() {
		return nil
	}
	if dec.err != nil {
		return nil
	}

	any := ast.DestructorDecl{}
	for {
		key, err := dec.scan.nextKey()
		if err != nil {
			if err == io.EOF {
				break
			}
			dec.err = err
			return nil
		}
		if key == "" {
			dec.err = errors.New("empty key")
			return nil
		}

		val, tok, err := dec.scan.nextValue()

		if err != nil {
			dec.err = err
			return nil
		}

		if tok != scanNullVal {
			switch key {

			case "doc":

				dec.scan.back()

				any.Doc = dec.decodeStrings()

			case "name":

				if tok != scanStringLit {
					dec.err = fmt.Errorf("expected 'String literal', found '%v'", tok)
					return nil
				}
				any.Name, dec.err = dec.unmarshalString(val)

			case "parameters":

				dec.scan.back()

				any.Params = dec.decodeFields()

			case "body":

				dec.scan.back()

				any.Body = dec.decodeStmts()

			case "visibility":

				if tok != scanStringLit {
					dec.err = fmt.Errorf("expected 'String literal', found '%v'", tok)
					return nil
				}
				any.Visibility, dec.err = dec.unmarshalString(val)

			case "loc":

				if tok != scanInt64Lit {
					dec.err = fmt.Errorf("expected 'Int64 literal', found '%v'", tok)
					return nil
				}
				any.LoC, dec.err = dec.unmarshalInt64(val)

			default:
				dec.err = fmt.Errorf("unexpected key '%s' for DestructorDecl object", key)
			}
		}

		if dec.err != nil {
			return nil
		}

		if dec.isEndObject() {
			break
		}
		if err != nil {
			return nil
		}
	}
	return &any
}

func (dec *decoder) decodeEnumDecl() *ast.EnumDecl {
	if dec.isNull() {
		return nil
	}
	if !dec.assertNewObject() {
		return nil
	}
	if dec.isEmptyObject() {
		return nil
	}
	if dec.err != nil {
		return nil
	}

	any := ast.EnumDecl{}
	for {
		key, err := dec.scan.nextKey()
		if err != nil {
			if err == io.EOF {
				break
			}
			dec.err = err
			return nil
		}
		if key == "" {
			dec.err = errors.New("empty key")
			return nil
		}

		val, tok, err := dec.scan.nextValue()

		if err != nil {
			dec.err = err
			return nil
		}

		if tok != scanNullVal {
			switch key {

			case "doc":

				dec.scan.back()

				any.Doc = dec.decodeStrings()

			case "name":

				if tok != scanStringLit {
					dec.err = fmt.Errorf("expected 'String literal', found '%v'", tok)
					return nil
				}
				any.Name, dec.err = dec.unmarshalString(val)

			case "visibility":

				if tok != scanStringLit {
					dec.err = fmt.Errorf("expected 'String literal', found '%v'", tok)
					return nil
				}
				any.Visibility, dec.err = dec.unmarshalString(val)

			case "implemented_interfaces":

				dec.scan.back()

				any.ImplementedInterfaces = dec.decodeInterfaceRefs()

			case "enum_constants":

				dec.scan.back()

				any.EnumConstants = dec.decodeIdents()

			case "attributes":

				dec.scan.back()

				any.Attrs = dec.decodeAttrs()

			case "constructors":

				dec.scan.back()

				any.Constructors = dec.decodeConstructorDecls()

			case "destructors":

				dec.scan.back()

				any.Destructors = dec.decodeDestructorDecls()

			case "methods":

				dec.scan.back()

				any.Methods = dec.decodeMethodDecls()

			default:
				dec.err = fmt.Errorf("unexpected key '%s' for EnumDecl object", key)
			}
		}

		if dec.err != nil {
			return nil
		}

		if dec.isEndObject() {
			break
		}
		if err != nil {
			return nil
		}
	}
	return &any
}

func (dec *decoder) decodeFuncDecl() *ast.FuncDecl {
	if dec.isNull() {
		return nil
	}
	if !dec.assertNewObject() {
		return nil
	}
	if dec.isEmptyObject() {
		return nil
	}
	if dec.err != nil {
		return nil
	}

	any := ast.FuncDecl{}
	for {
		key, err := dec.scan.nextKey()
		if err != nil {
			if err == io.EOF {
				break
			}
			dec.err = err
			return nil
		}
		if key == "" {
			dec.err = errors.New("empty key")
			return nil
		}

		val, tok, err := dec.scan.nextValue()

		if err != nil {
			dec.err = err
			return nil
		}

		if tok != scanNullVal {
			switch key {

			case "doc":

				dec.scan.back()

				any.Doc = dec.decodeStrings()

			case "name":

				if tok != scanStringLit {
					dec.err = fmt.Errorf("expected 'String literal', found '%v'", tok)
					return nil
				}
				any.Name, dec.err = dec.unmarshalString(val)

			case "type":

				dec.scan.back()

				any.Type = dec.decodeFuncType()

			case "body":

				dec.scan.back()

				any.Body = dec.decodeStmts()

			case "visibility":

				if tok != scanStringLit {
					dec.err = fmt.Errorf("expected 'String literal', found '%v'", tok)
					return nil
				}
				any.Visibility, dec.err = dec.unmarshalString(val)

			case "loc":

				if tok != scanInt64Lit {
					dec.err = fmt.Errorf("expected 'Int64 literal', found '%v'", tok)
					return nil
				}
				any.LoC, dec.err = dec.unmarshalInt64(val)

			default:
				dec.err = fmt.Errorf("unexpected key '%s' for FuncDecl object", key)
			}
		}

		if dec.err != nil {
			return nil
		}

		if dec.isEndObject() {
			break
		}
		if err != nil {
			return nil
		}
	}
	return &any
}

func (dec *decoder) decodeFuncRef() *ast.FuncRef {
	if dec.isNull() {
		return nil
	}
	if !dec.assertNewObject() {
		return nil
	}
	if dec.isEmptyObject() {
		return nil
	}
	if dec.err != nil {
		return nil
	}

	any := ast.FuncRef{}
	for {
		key, err := dec.scan.nextKey()
		if err != nil {
			if err == io.EOF {
				break
			}
			dec.err = err
			return nil
		}
		if key == "" {
			dec.err = errors.New("empty key")
			return nil
		}

		val, tok, err := dec.scan.nextValue()

		if err != nil {
			dec.err = err
			return nil
		}

		if tok != scanNullVal {
			switch key {

			case "namespace":

				if tok != scanStringLit {
					dec.err = fmt.Errorf("expected 'String literal', found '%v'", tok)
					return nil
				}
				any.Namespace, dec.err = dec.unmarshalString(val)

			case "function_name":

				if tok != scanStringLit {
					dec.err = fmt.Errorf("expected 'String literal', found '%v'", tok)
					return nil
				}
				any.FuncName, dec.err = dec.unmarshalString(val)

			default:
				dec.err = fmt.Errorf("unexpected key '%s' for FuncRef object", key)
			}
		}

		if dec.err != nil {
			return nil
		}

		if dec.isEndObject() {
			break
		}
		if err != nil {
			return nil
		}
	}
	return &any
}

func (dec *decoder) decodeFuncType() *ast.FuncType {
	if dec.isNull() {
		return nil
	}
	if !dec.assertNewObject() {
		return nil
	}
	if dec.isEmptyObject() {
		return nil
	}
	if dec.err != nil {
		return nil
	}

	any := ast.FuncType{}
	for {
		key, err := dec.scan.nextKey()
		if err != nil {
			if err == io.EOF {
				break
			}
			dec.err = err
			return nil
		}
		if key == "" {
			dec.err = errors.New("empty key")
			return nil
		}

		_, tok, err := dec.scan.nextValue()

		if err != nil {
			dec.err = err
			return nil
		}

		if tok != scanNullVal {
			switch key {

			case "parameters":

				dec.scan.back()

				any.Params = dec.decodeFields()

			case "results":

				dec.scan.back()

				any.Results = dec.decodeFields()

			default:
				dec.err = fmt.Errorf("unexpected key '%s' for FuncType object", key)
			}
		}

		if dec.err != nil {
			return nil
		}

		if dec.isEndObject() {
			break
		}
		if err != nil {
			return nil
		}
	}
	return &any
}

func (dec *decoder) decodeGlobalDecl() *ast.GlobalDecl {
	if dec.isNull() {
		return nil
	}
	if !dec.assertNewObject() {
		return nil
	}
	if dec.isEmptyObject() {
		return nil
	}
	if dec.err != nil {
		return nil
	}

	any := ast.GlobalDecl{}
	for {
		key, err := dec.scan.nextKey()
		if err != nil {
			if err == io.EOF {
				break
			}
			dec.err = err
			return nil
		}
		if key == "" {
			dec.err = errors.New("empty key")
			return nil
		}

		val, tok, err := dec.scan.nextValue()

		if err != nil {
			dec.err = err
			return nil
		}

		if tok != scanNullVal {
			switch key {

			case "doc":

				dec.scan.back()

				any.Doc = dec.decodeStrings()

			case "name":

				dec.scan.back()

				any.Name = dec.decodeIdent()

			case "value":

				dec.scan.back()

				any.Value = dec.decodeExpr()

			case "type":

				dec.scan.back()

				any.Type = dec.decodeIdent()

			case "visibility":

				if tok != scanStringLit {
					dec.err = fmt.Errorf("expected 'String literal', found '%v'", tok)
					return nil
				}
				any.Visibility, dec.err = dec.unmarshalString(val)

			default:
				dec.err = fmt.Errorf("unexpected key '%s' for GlobalDecl object", key)
			}
		}

		if dec.err != nil {
			return nil
		}

		if dec.isEndObject() {
			break
		}
		if err != nil {
			return nil
		}
	}
	return &any
}

func (dec *decoder) decodeInterface() *ast.Interface {
	if dec.isNull() {
		return nil
	}
	if !dec.assertNewObject() {
		return nil
	}
	if dec.isEmptyObject() {
		return nil
	}
	if dec.err != nil {
		return nil
	}

	any := ast.Interface{}
	for {
		key, err := dec.scan.nextKey()
		if err != nil {
			if err == io.EOF {
				break
			}
			dec.err = err
			return nil
		}
		if key == "" {
			dec.err = errors.New("empty key")
			return nil
		}

		val, tok, err := dec.scan.nextValue()

		if err != nil {
			dec.err = err
			return nil
		}

		if tok != scanNullVal {
			switch key {

			case "doc":

				dec.scan.back()

				any.Doc = dec.decodeStrings()

			case "name":

				if tok != scanStringLit {
					dec.err = fmt.Errorf("expected 'String literal', found '%v'", tok)
					return nil
				}
				any.Name, dec.err = dec.unmarshalString(val)

			case "implemented_interfaces":

				dec.scan.back()

				any.ImplementedInterfaces = dec.decodeInterfaceRefs()

			case "prototypes":

				dec.scan.back()

				any.Protos = dec.decodeProtoDecls()

			case "visibility":

				if tok != scanStringLit {
					dec.err = fmt.Errorf("expected 'String literal', found '%v'", tok)
					return nil
				}
				any.Visibility, dec.err = dec.unmarshalString(val)

			default:
				dec.err = fmt.Errorf("unexpected key '%s' for Interface object", key)
			}
		}

		if dec.err != nil {
			return nil
		}

		if dec.isEndObject() {
			break
		}
		if err != nil {
			return nil
		}
	}
	return &any
}

func (dec *decoder) decodeInterfaceRef() *ast.InterfaceRef {
	if dec.isNull() {
		return nil
	}
	if !dec.assertNewObject() {
		return nil
	}
	if dec.isEmptyObject() {
		return nil
	}
	if dec.err != nil {
		return nil
	}

	any := ast.InterfaceRef{}
	for {
		key, err := dec.scan.nextKey()
		if err != nil {
			if err == io.EOF {
				break
			}
			dec.err = err
			return nil
		}
		if key == "" {
			dec.err = errors.New("empty key")
			return nil
		}

		val, tok, err := dec.scan.nextValue()

		if err != nil {
			dec.err = err
			return nil
		}

		if tok != scanNullVal {
			switch key {

			case "namespace":

				if tok != scanStringLit {
					dec.err = fmt.Errorf("expected 'String literal', found '%v'", tok)
					return nil
				}
				any.Namespace, dec.err = dec.unmarshalString(val)

			case "interface_name":

				if tok != scanStringLit {
					dec.err = fmt.Errorf("expected 'String literal', found '%v'", tok)
					return nil
				}
				any.InterfaceName, dec.err = dec.unmarshalString(val)

			default:
				dec.err = fmt.Errorf("unexpected key '%s' for InterfaceRef object", key)
			}
		}

		if dec.err != nil {
			return nil
		}

		if dec.isEndObject() {
			break
		}
		if err != nil {
			return nil
		}
	}
	return &any
}

func (dec *decoder) decodeListLit() *ast.ListLit {
	if dec.isNull() {
		return nil
	}
	if !dec.assertNewObject() {
		return nil
	}
	if dec.isEmptyObject() {
		return nil
	}
	if dec.err != nil {
		return nil
	}

	any := ast.ListLit{}
	for {
		key, err := dec.scan.nextKey()
		if err != nil {
			if err == io.EOF {
				break
			}
			dec.err = err
			return nil
		}
		if key == "" {
			dec.err = errors.New("empty key")
			return nil
		}

		_, tok, err := dec.scan.nextValue()

		if err != nil {
			dec.err = err
			return nil
		}

		if tok != scanNullVal {
			switch key {

			case "type":

				dec.scan.back()

				any.Type = dec.decodeListType()

			case "elements":

				dec.scan.back()

				any.Elts = dec.decodeExprs()

			default:
				dec.err = fmt.Errorf("unexpected key '%s' for ListLit object", key)
			}
		}

		if dec.err != nil {
			return nil
		}

		if dec.isEndObject() {
			break
		}
		if err != nil {
			return nil
		}
	}
	return &any
}

func (dec *decoder) decodeListType() *ast.ListType {
	if dec.isNull() {
		return nil
	}
	if !dec.assertNewObject() {
		return nil
	}
	if dec.isEmptyObject() {
		return nil
	}
	if dec.err != nil {
		return nil
	}

	any := ast.ListType{}
	for {
		key, err := dec.scan.nextKey()
		if err != nil {
			if err == io.EOF {
				break
			}
			dec.err = err
			return nil
		}
		if key == "" {
			dec.err = errors.New("empty key")
			return nil
		}

		val, tok, err := dec.scan.nextValue()

		if err != nil {
			dec.err = err
			return nil
		}

		if tok != scanNullVal {
			switch key {

			case "length":

				if tok != scanInt64Lit {
					dec.err = fmt.Errorf("expected 'Int64 literal', found '%v'", tok)
					return nil
				}
				any.Len, dec.err = dec.unmarshalInt64(val)

			case "capacity":

				if tok != scanInt64Lit {
					dec.err = fmt.Errorf("expected 'Int64 literal', found '%v'", tok)
					return nil
				}
				any.Max, dec.err = dec.unmarshalInt64(val)

			case "element_type":

				dec.scan.back()

				any.Elt = dec.decodeExpr()

			default:
				dec.err = fmt.Errorf("unexpected key '%s' for ListType object", key)
			}
		}

		if dec.err != nil {
			return nil
		}

		if dec.isEndObject() {
			break
		}
		if err != nil {
			return nil
		}
	}
	return &any
}

func (dec *decoder) decodeMapLit() *ast.MapLit {
	if dec.isNull() {
		return nil
	}
	if !dec.assertNewObject() {
		return nil
	}
	if dec.isEmptyObject() {
		return nil
	}
	if dec.err != nil {
		return nil
	}

	any := ast.MapLit{}
	for {
		key, err := dec.scan.nextKey()
		if err != nil {
			if err == io.EOF {
				break
			}
			dec.err = err
			return nil
		}
		if key == "" {
			dec.err = errors.New("empty key")
			return nil
		}

		_, tok, err := dec.scan.nextValue()

		if err != nil {
			dec.err = err
			return nil
		}

		if tok != scanNullVal {
			switch key {

			case "type":

				dec.scan.back()

				any.Type = dec.decodeMapType()

			case "elements":

				dec.scan.back()

				any.Elts = dec.decodeKeyValuePairs()

			default:
				dec.err = fmt.Errorf("unexpected key '%s' for MapLit object", key)
			}
		}

		if dec.err != nil {
			return nil
		}

		if dec.isEndObject() {
			break
		}
		if err != nil {
			return nil
		}
	}
	return &any
}

func (dec *decoder) decodeKeyValuePair() *ast.KeyValuePair {
	if dec.isNull() {
		return nil
	}
	if !dec.assertNewObject() {
		return nil
	}
	if dec.isEmptyObject() {
		return nil
	}
	if dec.err != nil {
		return nil
	}

	any := ast.KeyValuePair{}
	for {
		key, err := dec.scan.nextKey()
		if err != nil {
			if err == io.EOF {
				break
			}
			dec.err = err
			return nil
		}
		if key == "" {
			dec.err = errors.New("empty key")
			return nil
		}

		_, tok, err := dec.scan.nextValue()

		if err != nil {
			dec.err = err
			return nil
		}

		if tok != scanNullVal {
			switch key {

			case "key":

				dec.scan.back()

				any.Key = dec.decodeExpr()

			case "value":

				dec.scan.back()

				any.Value = dec.decodeExpr()

			default:
				dec.err = fmt.Errorf("unexpected key '%s' for KeyValuePair object", key)
			}
		}

		if dec.err != nil {
			return nil
		}

		if dec.isEndObject() {
			break
		}
		if err != nil {
			return nil
		}
	}
	return &any
}

func (dec *decoder) decodeMapType() *ast.MapType {
	if dec.isNull() {
		return nil
	}
	if !dec.assertNewObject() {
		return nil
	}
	if dec.isEmptyObject() {
		return nil
	}
	if dec.err != nil {
		return nil
	}

	any := ast.MapType{}
	for {
		key, err := dec.scan.nextKey()
		if err != nil {
			if err == io.EOF {
				break
			}
			dec.err = err
			return nil
		}
		if key == "" {
			dec.err = errors.New("empty key")
			return nil
		}

		_, tok, err := dec.scan.nextValue()

		if err != nil {
			dec.err = err
			return nil
		}

		if tok != scanNullVal {
			switch key {

			case "key_type":

				dec.scan.back()

				any.KeyType = dec.decodeExpr()

			case "value_type":

				dec.scan.back()

				any.ValueType = dec.decodeExpr()

			default:
				dec.err = fmt.Errorf("unexpected key '%s' for MapType object", key)
			}
		}

		if dec.err != nil {
			return nil
		}

		if dec.isEndObject() {
			break
		}
		if err != nil {
			return nil
		}
	}
	return &any
}

func (dec *decoder) decodeMethodDecl() *ast.MethodDecl {
	if dec.isNull() {
		return nil
	}
	if !dec.assertNewObject() {
		return nil
	}
	if dec.isEmptyObject() {
		return nil
	}
	if dec.err != nil {
		return nil
	}

	any := ast.MethodDecl{}
	for {
		key, err := dec.scan.nextKey()
		if err != nil {
			if err == io.EOF {
				break
			}
			dec.err = err
			return nil
		}
		if key == "" {
			dec.err = errors.New("empty key")
			return nil
		}

		val, tok, err := dec.scan.nextValue()

		if err != nil {
			dec.err = err
			return nil
		}

		if tok != scanNullVal {
			switch key {

			case "doc":

				dec.scan.back()

				any.Doc = dec.decodeStrings()

			case "name":

				if tok != scanStringLit {
					dec.err = fmt.Errorf("expected 'String literal', found '%v'", tok)
					return nil
				}
				any.Name, dec.err = dec.unmarshalString(val)

			case "type":

				dec.scan.back()

				any.Type = dec.decodeFuncType()

			case "body":

				dec.scan.back()

				any.Body = dec.decodeStmts()

			case "visibility":

				if tok != scanStringLit {
					dec.err = fmt.Errorf("expected 'String literal', found '%v'", tok)
					return nil
				}
				any.Visibility, dec.err = dec.unmarshalString(val)

			case "loc":

				if tok != scanInt64Lit {
					dec.err = fmt.Errorf("expected 'Int64 literal', found '%v'", tok)
					return nil
				}
				any.LoC, dec.err = dec.unmarshalInt64(val)

			case "override":

				if tok != scanBoolLit {
					dec.err = fmt.Errorf("expected 'Bool literal', found '%v'", tok)
					return nil
				}
				any.Override, dec.err = dec.unmarshalBool(val)

			default:
				dec.err = fmt.Errorf("unexpected key '%s' for MethodDecl object", key)
			}
		}

		if dec.err != nil {
			return nil
		}

		if dec.isEndObject() {
			break
		}
		if err != nil {
			return nil
		}
	}
	return &any
}

func (dec *decoder) decodeProtoDecl() *ast.ProtoDecl {
	if dec.isNull() {
		return nil
	}
	if !dec.assertNewObject() {
		return nil
	}
	if dec.isEmptyObject() {
		return nil
	}
	if dec.err != nil {
		return nil
	}

	any := ast.ProtoDecl{}
	for {
		key, err := dec.scan.nextKey()
		if err != nil {
			if err == io.EOF {
				break
			}
			dec.err = err
			return nil
		}
		if key == "" {
			dec.err = errors.New("empty key")
			return nil
		}

		val, tok, err := dec.scan.nextValue()

		if err != nil {
			dec.err = err
			return nil
		}

		if tok != scanNullVal {
			switch key {

			case "doc":

				dec.scan.back()

				any.Doc = dec.decodeStrings()

			case "name":

				dec.scan.back()

				any.Name = dec.decodeIdent()

			case "type":

				dec.scan.back()

				any.Type = dec.decodeFuncType()

			case "visibility":

				if tok != scanStringLit {
					dec.err = fmt.Errorf("expected 'String literal', found '%v'", tok)
					return nil
				}
				any.Visibility, dec.err = dec.unmarshalString(val)

			default:
				dec.err = fmt.Errorf("unexpected key '%s' for ProtoDecl object", key)
			}
		}

		if dec.err != nil {
			return nil
		}

		if dec.isEndObject() {
			break
		}
		if err != nil {
			return nil
		}
	}
	return &any
}

func (dec *decoder) decodeField() *ast.Field {
	if dec.isNull() {
		return nil
	}
	if !dec.assertNewObject() {
		return nil
	}
	if dec.isEmptyObject() {
		return nil
	}
	if dec.err != nil {
		return nil
	}

	any := ast.Field{}
	for {
		key, err := dec.scan.nextKey()
		if err != nil {
			if err == io.EOF {
				break
			}
			dec.err = err
			return nil
		}
		if key == "" {
			dec.err = errors.New("empty key")
			return nil
		}

		val, tok, err := dec.scan.nextValue()

		if err != nil {
			dec.err = err
			return nil
		}

		if tok != scanNullVal {
			switch key {

			case "doc":

				dec.scan.back()

				any.Doc = dec.decodeStrings()

			case "name":

				if tok != scanStringLit {
					dec.err = fmt.Errorf("expected 'String literal', found '%v'", tok)
					return nil
				}
				any.Name, dec.err = dec.unmarshalString(val)

			case "type":

				if tok != scanStringLit {
					dec.err = fmt.Errorf("expected 'String literal', found '%v'", tok)
					return nil
				}
				any.Type, dec.err = dec.unmarshalString(val)

			default:
				dec.err = fmt.Errorf("unexpected key '%s' for Field object", key)
			}
		}

		if dec.err != nil {
			return nil
		}

		if dec.isEndObject() {
			break
		}
		if err != nil {
			return nil
		}
	}
	return &any
}

func (dec *decoder) decodeCaseClause() *ast.CaseClause {
	if dec.isNull() {
		return nil
	}
	if !dec.assertNewObject() {
		return nil
	}
	if dec.isEmptyObject() {
		return nil
	}
	if dec.err != nil {
		return nil
	}

	any := ast.CaseClause{}
	for {
		key, err := dec.scan.nextKey()
		if err != nil {
			if err == io.EOF {
				break
			}
			dec.err = err
			return nil
		}
		if key == "" {
			dec.err = errors.New("empty key")
			return nil
		}

		_, tok, err := dec.scan.nextValue()

		if err != nil {
			dec.err = err
			return nil
		}

		if tok != scanNullVal {
			switch key {

			case "conditions":

				dec.scan.back()

				any.Conds = dec.decodeExprs()

			case "body":

				dec.scan.back()

				any.Body = dec.decodeStmts()

			default:
				dec.err = fmt.Errorf("unexpected key '%s' for CaseClause object", key)
			}
		}

		if dec.err != nil {
			return nil
		}

		if dec.isEndObject() {
			break
		}
		if err != nil {
			return nil
		}
	}
	return &any
}

func (dec *decoder) decodeTrait() *ast.Trait {
	if dec.isNull() {
		return nil
	}
	if !dec.assertNewObject() {
		return nil
	}
	if dec.isEmptyObject() {
		return nil
	}
	if dec.err != nil {
		return nil
	}

	any := ast.Trait{}
	for {
		key, err := dec.scan.nextKey()
		if err != nil {
			if err == io.EOF {
				break
			}
			dec.err = err
			return nil
		}
		if key == "" {
			dec.err = errors.New("empty key")
			return nil
		}

		val, tok, err := dec.scan.nextValue()

		if err != nil {
			dec.err = err
			return nil
		}

		if tok != scanNullVal {
			switch key {

			case "name":

				if tok != scanStringLit {
					dec.err = fmt.Errorf("expected 'String literal', found '%v'", tok)
					return nil
				}
				any.Name, dec.err = dec.unmarshalString(val)

			case "attributes":

				dec.scan.back()

				any.Attrs = dec.decodeAttrs()

			case "methods":

				dec.scan.back()

				any.Methods = dec.decodeMethodDecls()

			case "classes":

				dec.scan.back()

				any.Classes = dec.decodeClassDecls()

			case "traits":

				dec.scan.back()

				any.Traits = dec.decodeTraits()

			default:
				dec.err = fmt.Errorf("unexpected key '%s' for Trait object", key)
			}
		}

		if dec.err != nil {
			return nil
		}

		if dec.isEndObject() {
			break
		}
		if err != nil {
			return nil
		}
	}
	return &any
}

func (dec *decoder) decodeTraitRef() *ast.TraitRef {
	if dec.isNull() {
		return nil
	}
	if !dec.assertNewObject() {
		return nil
	}
	if dec.isEmptyObject() {
		return nil
	}
	if dec.err != nil {
		return nil
	}

	any := ast.TraitRef{}
	for {
		key, err := dec.scan.nextKey()
		if err != nil {
			if err == io.EOF {
				break
			}
			dec.err = err
			return nil
		}
		if key == "" {
			dec.err = errors.New("empty key")
			return nil
		}

		val, tok, err := dec.scan.nextValue()

		if err != nil {
			dec.err = err
			return nil
		}

		if tok != scanNullVal {
			switch key {

			case "namespace":

				if tok != scanStringLit {
					dec.err = fmt.Errorf("expected 'String literal', found '%v'", tok)
					return nil
				}
				any.Namespace, dec.err = dec.unmarshalString(val)

			case "trait_name":

				if tok != scanStringLit {
					dec.err = fmt.Errorf("expected 'String literal', found '%v'", tok)
					return nil
				}
				any.TraitName, dec.err = dec.unmarshalString(val)

			default:
				dec.err = fmt.Errorf("unexpected key '%s' for TraitRef object", key)
			}
		}

		if dec.err != nil {
			return nil
		}

		if dec.isEndObject() {
			break
		}
		if err != nil {
			return nil
		}
	}
	return &any
}

func (dec *decoder) decodeCatchClause() *ast.CatchClause {
	if dec.isNull() {
		return nil
	}
	if !dec.assertNewObject() {
		return nil
	}
	if dec.isEmptyObject() {
		return nil
	}
	if dec.err != nil {
		return nil
	}

	any := ast.CatchClause{}
	for {
		key, err := dec.scan.nextKey()
		if err != nil {
			if err == io.EOF {
				break
			}
			dec.err = err
			return nil
		}
		if key == "" {
			dec.err = errors.New("empty key")
			return nil
		}

		_, tok, err := dec.scan.nextValue()

		if err != nil {
			dec.err = err
			return nil
		}

		if tok != scanNullVal {
			switch key {

			case "parameters":

				dec.scan.back()

				any.Params = dec.decodeFields()

			case "body":

				dec.scan.back()

				any.Body = dec.decodeStmts()

			default:
				dec.err = fmt.Errorf("unexpected key '%s' for CatchClause object", key)
			}
		}

		if dec.err != nil {
			return nil
		}

		if dec.isEndObject() {
			break
		}
		if err != nil {
			return nil
		}
	}
	return &any
}

func (dec *decoder) decodeTypeSpec() *ast.TypeSpec {
	if dec.isNull() {
		return nil
	}
	if !dec.assertNewObject() {
		return nil
	}
	if dec.isEmptyObject() {
		return nil
	}
	if dec.err != nil {
		return nil
	}

	any := ast.TypeSpec{}
	for {
		key, err := dec.scan.nextKey()
		if err != nil {
			if err == io.EOF {
				break
			}
			dec.err = err
			return nil
		}
		if key == "" {
			dec.err = errors.New("empty key")
			return nil
		}

		_, tok, err := dec.scan.nextValue()

		if err != nil {
			dec.err = err
			return nil
		}

		if tok != scanNullVal {
			switch key {

			case "doc":

				dec.scan.back()

				any.Doc = dec.decodeStrings()

			case "name":

				dec.scan.back()

				any.Name = dec.decodeIdent()

			case "type":

				dec.scan.back()

				any.Type = dec.decodeExpr()

			default:
				dec.err = fmt.Errorf("unexpected key '%s' for TypeSpec object", key)
			}
		}

		if dec.err != nil {
			return nil
		}

		if dec.isEndObject() {
			break
		}
		if err != nil {
			return nil
		}
	}
	return &any
}

func (dec *decoder) decodeVar() *ast.Var {
	if dec.isNull() {
		return nil
	}
	if !dec.assertNewObject() {
		return nil
	}
	if dec.isEmptyObject() {
		return nil
	}
	if dec.err != nil {
		return nil
	}

	any := ast.Var{}
	for {
		key, err := dec.scan.nextKey()
		if err != nil {
			if err == io.EOF {
				break
			}
			dec.err = err
			return nil
		}
		if key == "" {
			dec.err = errors.New("empty key")
			return nil
		}

		val, tok, err := dec.scan.nextValue()

		if err != nil {
			dec.err = err
			return nil
		}

		if tok != scanNullVal {
			switch key {

			case "doc":

				dec.scan.back()

				any.Doc = dec.decodeStrings()

			case "name":

				if tok != scanStringLit {
					dec.err = fmt.Errorf("expected 'String literal', found '%v'", tok)
					return nil
				}
				any.Name, dec.err = dec.unmarshalString(val)

			case "type":

				if tok != scanStringLit {
					dec.err = fmt.Errorf("expected 'String literal', found '%v'", tok)
					return nil
				}
				any.Type, dec.err = dec.unmarshalString(val)

			case "value":

				if tok != scanStringLit {
					dec.err = fmt.Errorf("expected 'String literal', found '%v'", tok)
					return nil
				}
				any.Value, dec.err = dec.unmarshalString(val)

			case "is_pointer":

				if tok != scanBoolLit {
					dec.err = fmt.Errorf("expected 'Bool literal', found '%v'", tok)
					return nil
				}
				any.IsPointer, dec.err = dec.unmarshalBool(val)

			case "visibility":

				if tok != scanStringLit {
					dec.err = fmt.Errorf("expected 'String literal', found '%v'", tok)
					return nil
				}
				any.Visibility, dec.err = dec.unmarshalString(val)

			default:
				dec.err = fmt.Errorf("unexpected key '%s' for Var object", key)
			}
		}

		if dec.err != nil {
			return nil
		}

		if dec.isEndObject() {
			break
		}
		if err != nil {
			return nil
		}
	}
	return &any
}

func (dec *decoder) decodeArrayTypes() []*ast.ArrayType {
	if !dec.assertNewArray() {
		return nil
	}

	a := []*ast.ArrayType{}

	if dec.isEmptyArray() {
		return a
	}
	if dec.err != nil {
		return nil
	}

	for {
		elt := dec.decodeArrayType()
		if dec.err != nil {
			return nil
		}

		a = append(a, elt)

		if dec.isEndArray() {
			break
		}
		if dec.err != nil {
			return nil
		}
	}

	return a
}

func (dec *decoder) decodeAttrs() []*ast.Attr {
	if !dec.assertNewArray() {
		return nil
	}

	a := []*ast.Attr{}

	if dec.isEmptyArray() {
		return a
	}
	if dec.err != nil {
		return nil
	}

	for {
		elt := dec.decodeAttr()
		if dec.err != nil {
			return nil
		}

		a = append(a, elt)

		if dec.isEndArray() {
			break
		}
		if dec.err != nil {
			return nil
		}
	}

	return a
}

func (dec *decoder) decodeClassDecls() []*ast.ClassDecl {
	if !dec.assertNewArray() {
		return nil
	}

	a := []*ast.ClassDecl{}

	if dec.isEmptyArray() {
		return a
	}
	if dec.err != nil {
		return nil
	}

	for {
		elt := dec.decodeClassDecl()
		if dec.err != nil {
			return nil
		}

		a = append(a, elt)

		if dec.isEndArray() {
			break
		}
		if dec.err != nil {
			return nil
		}
	}

	return a
}

func (dec *decoder) decodeClassRefs() []*ast.ClassRef {
	if !dec.assertNewArray() {
		return nil
	}

	a := []*ast.ClassRef{}

	if dec.isEmptyArray() {
		return a
	}
	if dec.err != nil {
		return nil
	}

	for {
		elt := dec.decodeClassRef()
		if dec.err != nil {
			return nil
		}

		a = append(a, elt)

		if dec.isEndArray() {
			break
		}
		if dec.err != nil {
			return nil
		}
	}

	return a
}

func (dec *decoder) decodeConstants() []*ast.Constant {
	if !dec.assertNewArray() {
		return nil
	}

	a := []*ast.Constant{}

	if dec.isEmptyArray() {
		return a
	}
	if dec.err != nil {
		return nil
	}

	for {
		elt := dec.decodeConstant()
		if dec.err != nil {
			return nil
		}

		a = append(a, elt)

		if dec.isEndArray() {
			break
		}
		if dec.err != nil {
			return nil
		}
	}

	return a
}

func (dec *decoder) decodeConstructorDecls() []*ast.ConstructorDecl {
	if !dec.assertNewArray() {
		return nil
	}

	a := []*ast.ConstructorDecl{}

	if dec.isEmptyArray() {
		return a
	}
	if dec.err != nil {
		return nil
	}

	for {
		elt := dec.decodeConstructorDecl()
		if dec.err != nil {
			return nil
		}

		a = append(a, elt)

		if dec.isEndArray() {
			break
		}
		if dec.err != nil {
			return nil
		}
	}

	return a
}

func (dec *decoder) decodeDestructorDecls() []*ast.DestructorDecl {
	if !dec.assertNewArray() {
		return nil
	}

	a := []*ast.DestructorDecl{}

	if dec.isEmptyArray() {
		return a
	}
	if dec.err != nil {
		return nil
	}

	for {
		elt := dec.decodeDestructorDecl()
		if dec.err != nil {
			return nil
		}

		a = append(a, elt)

		if dec.isEndArray() {
			break
		}
		if dec.err != nil {
			return nil
		}
	}

	return a
}

func (dec *decoder) decodeEnumDecls() []*ast.EnumDecl {
	if !dec.assertNewArray() {
		return nil
	}

	a := []*ast.EnumDecl{}

	if dec.isEmptyArray() {
		return a
	}
	if dec.err != nil {
		return nil
	}

	for {
		elt := dec.decodeEnumDecl()
		if dec.err != nil {
			return nil
		}

		a = append(a, elt)

		if dec.isEndArray() {
			break
		}
		if dec.err != nil {
			return nil
		}
	}

	return a
}

func (dec *decoder) decodeFuncDecls() []*ast.FuncDecl {
	if !dec.assertNewArray() {
		return nil
	}

	a := []*ast.FuncDecl{}

	if dec.isEmptyArray() {
		return a
	}
	if dec.err != nil {
		return nil
	}

	for {
		elt := dec.decodeFuncDecl()
		if dec.err != nil {
			return nil
		}

		a = append(a, elt)

		if dec.isEndArray() {
			break
		}
		if dec.err != nil {
			return nil
		}
	}

	return a
}

func (dec *decoder) decodeFuncRefs() []*ast.FuncRef {
	if !dec.assertNewArray() {
		return nil
	}

	a := []*ast.FuncRef{}

	if dec.isEmptyArray() {
		return a
	}
	if dec.err != nil {
		return nil
	}

	for {
		elt := dec.decodeFuncRef()
		if dec.err != nil {
			return nil
		}

		a = append(a, elt)

		if dec.isEndArray() {
			break
		}
		if dec.err != nil {
			return nil
		}
	}

	return a
}

func (dec *decoder) decodeFuncTypes() []*ast.FuncType {
	if !dec.assertNewArray() {
		return nil
	}

	a := []*ast.FuncType{}

	if dec.isEmptyArray() {
		return a
	}
	if dec.err != nil {
		return nil
	}

	for {
		elt := dec.decodeFuncType()
		if dec.err != nil {
			return nil
		}

		a = append(a, elt)

		if dec.isEndArray() {
			break
		}
		if dec.err != nil {
			return nil
		}
	}

	return a
}

func (dec *decoder) decodeGlobalDecls() []*ast.GlobalDecl {
	if !dec.assertNewArray() {
		return nil
	}

	a := []*ast.GlobalDecl{}

	if dec.isEmptyArray() {
		return a
	}
	if dec.err != nil {
		return nil
	}

	for {
		elt := dec.decodeGlobalDecl()
		if dec.err != nil {
			return nil
		}

		a = append(a, elt)

		if dec.isEndArray() {
			break
		}
		if dec.err != nil {
			return nil
		}
	}

	return a
}

func (dec *decoder) decodeInterfaces() []*ast.Interface {
	if !dec.assertNewArray() {
		return nil
	}

	a := []*ast.Interface{}

	if dec.isEmptyArray() {
		return a
	}
	if dec.err != nil {
		return nil
	}

	for {
		elt := dec.decodeInterface()
		if dec.err != nil {
			return nil
		}

		a = append(a, elt)

		if dec.isEndArray() {
			break
		}
		if dec.err != nil {
			return nil
		}
	}

	return a
}

func (dec *decoder) decodeInterfaceRefs() []*ast.InterfaceRef {
	if !dec.assertNewArray() {
		return nil
	}

	a := []*ast.InterfaceRef{}

	if dec.isEmptyArray() {
		return a
	}
	if dec.err != nil {
		return nil
	}

	for {
		elt := dec.decodeInterfaceRef()
		if dec.err != nil {
			return nil
		}

		a = append(a, elt)

		if dec.isEndArray() {
			break
		}
		if dec.err != nil {
			return nil
		}
	}

	return a
}

func (dec *decoder) decodeListLits() []*ast.ListLit {
	if !dec.assertNewArray() {
		return nil
	}

	a := []*ast.ListLit{}

	if dec.isEmptyArray() {
		return a
	}
	if dec.err != nil {
		return nil
	}

	for {
		elt := dec.decodeListLit()
		if dec.err != nil {
			return nil
		}

		a = append(a, elt)

		if dec.isEndArray() {
			break
		}
		if dec.err != nil {
			return nil
		}
	}

	return a
}

func (dec *decoder) decodeListTypes() []*ast.ListType {
	if !dec.assertNewArray() {
		return nil
	}

	a := []*ast.ListType{}

	if dec.isEmptyArray() {
		return a
	}
	if dec.err != nil {
		return nil
	}

	for {
		elt := dec.decodeListType()
		if dec.err != nil {
			return nil
		}

		a = append(a, elt)

		if dec.isEndArray() {
			break
		}
		if dec.err != nil {
			return nil
		}
	}

	return a
}

func (dec *decoder) decodeMapLits() []*ast.MapLit {
	if !dec.assertNewArray() {
		return nil
	}

	a := []*ast.MapLit{}

	if dec.isEmptyArray() {
		return a
	}
	if dec.err != nil {
		return nil
	}

	for {
		elt := dec.decodeMapLit()
		if dec.err != nil {
			return nil
		}

		a = append(a, elt)

		if dec.isEndArray() {
			break
		}
		if dec.err != nil {
			return nil
		}
	}

	return a
}

func (dec *decoder) decodeKeyValuePairs() []*ast.KeyValuePair {
	if !dec.assertNewArray() {
		return nil
	}

	a := []*ast.KeyValuePair{}

	if dec.isEmptyArray() {
		return a
	}
	if dec.err != nil {
		return nil
	}

	for {
		elt := dec.decodeKeyValuePair()
		if dec.err != nil {
			return nil
		}

		a = append(a, elt)

		if dec.isEndArray() {
			break
		}
		if dec.err != nil {
			return nil
		}
	}

	return a
}

func (dec *decoder) decodeMapTypes() []*ast.MapType {
	if !dec.assertNewArray() {
		return nil
	}

	a := []*ast.MapType{}

	if dec.isEmptyArray() {
		return a
	}
	if dec.err != nil {
		return nil
	}

	for {
		elt := dec.decodeMapType()
		if dec.err != nil {
			return nil
		}

		a = append(a, elt)

		if dec.isEndArray() {
			break
		}
		if dec.err != nil {
			return nil
		}
	}

	return a
}

func (dec *decoder) decodeMethodDecls() []*ast.MethodDecl {
	if !dec.assertNewArray() {
		return nil
	}

	a := []*ast.MethodDecl{}

	if dec.isEmptyArray() {
		return a
	}
	if dec.err != nil {
		return nil
	}

	for {
		elt := dec.decodeMethodDecl()
		if dec.err != nil {
			return nil
		}

		a = append(a, elt)

		if dec.isEndArray() {
			break
		}
		if dec.err != nil {
			return nil
		}
	}

	return a
}

func (dec *decoder) decodeProtoDecls() []*ast.ProtoDecl {
	if !dec.assertNewArray() {
		return nil
	}

	a := []*ast.ProtoDecl{}

	if dec.isEmptyArray() {
		return a
	}
	if dec.err != nil {
		return nil
	}

	for {
		elt := dec.decodeProtoDecl()
		if dec.err != nil {
			return nil
		}

		a = append(a, elt)

		if dec.isEndArray() {
			break
		}
		if dec.err != nil {
			return nil
		}
	}

	return a
}

func (dec *decoder) decodeFields() []*ast.Field {
	if !dec.assertNewArray() {
		return nil
	}

	a := []*ast.Field{}

	if dec.isEmptyArray() {
		return a
	}
	if dec.err != nil {
		return nil
	}

	for {
		elt := dec.decodeField()
		if dec.err != nil {
			return nil
		}

		a = append(a, elt)

		if dec.isEndArray() {
			break
		}
		if dec.err != nil {
			return nil
		}
	}

	return a
}

func (dec *decoder) decodeCaseClauses() []*ast.CaseClause {
	if !dec.assertNewArray() {
		return nil
	}

	a := []*ast.CaseClause{}

	if dec.isEmptyArray() {
		return a
	}
	if dec.err != nil {
		return nil
	}

	for {
		elt := dec.decodeCaseClause()
		if dec.err != nil {
			return nil
		}

		a = append(a, elt)

		if dec.isEndArray() {
			break
		}
		if dec.err != nil {
			return nil
		}
	}

	return a
}

func (dec *decoder) decodeTraits() []*ast.Trait {
	if !dec.assertNewArray() {
		return nil
	}

	a := []*ast.Trait{}

	if dec.isEmptyArray() {
		return a
	}
	if dec.err != nil {
		return nil
	}

	for {
		elt := dec.decodeTrait()
		if dec.err != nil {
			return nil
		}

		a = append(a, elt)

		if dec.isEndArray() {
			break
		}
		if dec.err != nil {
			return nil
		}
	}

	return a
}

func (dec *decoder) decodeTraitRefs() []*ast.TraitRef {
	if !dec.assertNewArray() {
		return nil
	}

	a := []*ast.TraitRef{}

	if dec.isEmptyArray() {
		return a
	}
	if dec.err != nil {
		return nil
	}

	for {
		elt := dec.decodeTraitRef()
		if dec.err != nil {
			return nil
		}

		a = append(a, elt)

		if dec.isEndArray() {
			break
		}
		if dec.err != nil {
			return nil
		}
	}

	return a
}

func (dec *decoder) decodeCatchClauses() []*ast.CatchClause {
	if !dec.assertNewArray() {
		return nil
	}

	a := []*ast.CatchClause{}

	if dec.isEmptyArray() {
		return a
	}
	if dec.err != nil {
		return nil
	}

	for {
		elt := dec.decodeCatchClause()
		if dec.err != nil {
			return nil
		}

		a = append(a, elt)

		if dec.isEndArray() {
			break
		}
		if dec.err != nil {
			return nil
		}
	}

	return a
}

func (dec *decoder) decodeTypeSpecs() []*ast.TypeSpec {
	if !dec.assertNewArray() {
		return nil
	}

	a := []*ast.TypeSpec{}

	if dec.isEmptyArray() {
		return a
	}
	if dec.err != nil {
		return nil
	}

	for {
		elt := dec.decodeTypeSpec()
		if dec.err != nil {
			return nil
		}

		a = append(a, elt)

		if dec.isEndArray() {
			break
		}
		if dec.err != nil {
			return nil
		}
	}

	return a
}

func (dec *decoder) decodeVars() []*ast.Var {
	if !dec.assertNewArray() {
		return nil
	}

	a := []*ast.Var{}

	if dec.isEmptyArray() {
		return a
	}
	if dec.err != nil {
		return nil
	}

	for {
		elt := dec.decodeVar()
		if dec.err != nil {
			return nil
		}

		a = append(a, elt)

		if dec.isEndArray() {
			break
		}
		if dec.err != nil {
			return nil
		}
	}

	return a
}
